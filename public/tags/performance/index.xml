<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Minko Gechev&#39;s blog</title>
    <link>http://blog.mgechev.com/tags/performance/</link>
    <description>Recent content in Performance on Minko Gechev&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.mgechev.com/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Faster Angular Applications - Understanding Differs. Developing a Custom IterableDiffer</title>
      <link>http://blog.mgechev.com/2017/11/14/angular-iterablediffer-keyvaluediffer-custom-differ-track-by-fn-performance/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2017/11/14/angular-iterablediffer-keyvaluediffer-custom-differ-track-by-fn-performance/</guid>
      <description>In this article we&amp;rsquo;ll take a look at another Angular abstraction - the differs and more specifically the IterableDiffer; we&amp;rsquo;ll explain what the differs are and how the framework uses them internally. After that, we&amp;rsquo;ll take a look at how NgForOf works and design a custom data structure optimized for the directive. Finally, we&amp;rsquo;ll develop a custom differ which will speed up the change detection mechanism of Angular when working with large collections.</description>
    </item>
    
    <item>
      <title>Faster Angular Applications - Part 2. Pure Pipes, Pure Functions and Memoization</title>
      <link>http://blog.mgechev.com/2017/11/12/faster-angular-applications-pure-pipes-memoization-pure-functions-part-2/</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2017/11/12/faster-angular-applications-pure-pipes-memoization-pure-functions-part-2/</guid>
      <description>In this post we&amp;rsquo;ll focus on techniques from functional programming we can apply in order to improve the performance of our applications, more specifically pure pipes, memoization, and referential transparency. If you haven&amp;rsquo;t read the first part of the &amp;ldquo;Faster Angular Applications&amp;rdquo; series, I&amp;rsquo;d recommend you to take a look at it or at least get familiar with the structure of the business application that we&amp;rsquo;re optimizing.
The code for this blog post is available at my GitHub account:</description>
    </item>
    
    <item>
      <title>Faster Angular Applications - Part 1. On Push Change Detection and Immutability</title>
      <link>http://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/</guid>
      <description>On AngularConnect 2017 in London I gave a talk called &amp;ldquo;Purely Fast&amp;rdquo;. In the presentation I shown how step by step we can improve the performance of a business application. In the example I incorporated as many performance issues as possible which I faced over the past a couple of years developing enterprise Angular and AngularJS applications. After the presentation I got great feedback for the content so I decided to write a series of blog posts which aim to explain the content from &amp;ldquo;Purely Fast&amp;rdquo; in details.</description>
    </item>
    
    <item>
      <title>Angular 2 Hot Loader</title>
      <link>http://blog.mgechev.com/2015/10/26/angular2-hot-loader-hot-loading-tooling/</link>
      <pubDate>Mon, 26 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/10/26/angular2-hot-loader-hot-loading-tooling/</guid>
      <description>A couple of months ago I watched a few talks from ReactEurope. I was truly impressed by a few of them and especially by the one by Dan Abramov on redux and his hot loader. The tool he shown helps you do something similar to live-reload with one big difference. When you change the code of any of the components in your react application, the new version of the component is send to the application itself where all its instances are patched so the changes you did to be visible.</description>
    </item>
    
    <item>
      <title>Lazy Loading of Route Components in Angular 2</title>
      <link>http://blog.mgechev.com/2015/09/30/lazy-loading-components-routes-services-router-angular-2/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/09/30/lazy-loading-components-routes-services-router-angular-2/</guid>
      <description>Warning: This version of the Angular 2 router is now deprecated! This means that soon the used below APIs will no longer be available.  For the examples in the content below I&amp;rsquo;ve used the angular2-seed project. The code for the article could be found at my GitHub account.
This blog post is mostly about performance and more accurately - lazy loading. Before we get started lets make a quick recap of what problem we&amp;rsquo;re about to solve.</description>
    </item>
    
    <item>
      <title>Lazy prefetching of AngularJS partials</title>
      <link>http://blog.mgechev.com/2013/10/01/angularjs-partials-lazy-prefetching-strategy-weighted-directed-graph/</link>
      <pubDate>Tue, 01 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2013/10/01/angularjs-partials-lazy-prefetching-strategy-weighted-directed-graph/</guid>
      <description>This blog post is concentrated about web performance. I’ll skip the well known stuff about combining images into sprites, inlining images, DNS pre-fetching, combining and minifying script files, gzipping and so on. There are plenty of articles and tools which will help you about these things. There are also excellent researches on these topics, few of the best I’ve read are these by Mobify, Web Performance Daybook Volume, High Performance Web Sites and Critical rendering path – Crash course on web performance and many others.</description>
    </item>
    
    <item>
      <title>Looking for performance? Probably you should NOT use [].sort (V8)</title>
      <link>http://blog.mgechev.com/2012/11/24/javascript-sorting-performance-quicksort-v8/</link>
      <pubDate>Sat, 24 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2012/11/24/javascript-sorting-performance-quicksort-v8/</guid>
      <description>A few days ago, I’ve created a GitHub repository. It’s main goal was to collect different algorithms with implementations in JavaScript. I started with basic ones – sorting (insertion, selection, bubble sort..). After that I implemented few “more advance” like marge, quick and heap sort. It was interesting to me how much slower my implementation will be compared to the default sort. It was so interesting because of:
function sort() { [native code] }  That’s why I’ve wrote not optimized version of mergesort and I’ve run it with generated array with 500k elements.</description>
    </item>
    
    <item>
      <title>Caching CSS with localStorage</title>
      <link>http://blog.mgechev.com/2012/09/04/caching-css-in-the-localstorage/</link>
      <pubDate>Tue, 04 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2012/09/04/caching-css-in-the-localstorage/</guid>
      <description>Since HTML5 became wide supported the most popular aspects I hear about were it’s canvas, WebSockets and localStorage. I’ve got very close experience with the first two of the mentioned but the localStorage was somehow unknown for me since a month. I’ve researched the topic. Actually it’s quite interesting and useful as you might guess. Using localStorage you can save different kinds of data locally into key-value pairs. The data lives on your local machine until it’s deleted (cleared).</description>
    </item>
    
  </channel>
</rss>