    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		<meta name="generator" content="Hugo 0.91.2" />
		<title>Boost the Performance of an AngularJS Application Using Immutable Data - Part 2 &middot; Minko Gechev&#39;s blog</title>
		<link rel="shortcut icon" href="https://blog.mgechev.com/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/highlight.css">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/style.css">
		

		
		<link rel="stylesheet" href="https://blog.mgechev.com/css/font-awesome.min.css">
		

		
		<link href="https://blog.mgechev.com/feed.xml" rel="alternate" type="application/rss+xml" title="Minko Gechev&#39;s blog">
		
		
		<link rel="amphtml" href="https://blog.mgechev.com/amp/2015/04/11/immutability-in-angularjs-immutablejs-part-2/">
		

		<meta property="og:title" content="Boost the Performance of an AngularJS Application Using Immutable Data - Part 2" />
		<meta property="og:description" content="A few weeks ago I posted the article &ldquo;Boost the Performance of an AngularJS Application Using Immutable Data&rdquo;. It shows how to speedup your AngularJS application when having a lot of bindings to big data collections. The idea behind the optimization is quite simple - create a new collection when the data changes. This way you can reduce the watchers execution from O(n) to O(1).
In the post I did simple profiling using the built-in Date but it didn&rsquo;t give enough information in exactly which cases it is more suitable to use immutable data and when you should bet on the standard collections." />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://blog.mgechev.com/2015/04/11/immutability-in-angularjs-immutablejs-part-2/" />
		
		<meta property="og:image" content="https://blog.mgechev.com/images/myself.jpg"/>
		<meta property="og:image:secure_url" content="https://blog.mgechev.com/images/myself.jpg"/>
		
	</head>

    <body>
       <nav class="main-nav">
  
  <div class="link-wrapper">
	
	
		<a href='https://blog.mgechev.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blog.mgechev.com/post'>Posts</a>
	<a href='https://blog.mgechev.com/about'>About</a>
	<a href='https://blog.mgechev.com/talks'>Speaking</a>
  </div>

	

	
  
	
</nav>
<a href="https://github.com/mgechev" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="z-index: 100000; fill:#70B7FD; color:#fff; position: fixed; top: 20px; border: 0; left: 20px; transform: scale(-1.5, 1.5);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Boost the Performance of an AngularJS Application Using Immutable Data - Part 2
                    </h1>
                    <h2 class="headline">
                    <a href="https://github.com/mgechev/blog.mgechev.com/tree/master/content/post/2015-04-11-immutability-in-angularjs-immutablejs-part-2.md">
                        <i class="fa fa-pencil-square-o"></i> Edit
                    </a>
                    · Apr 11, 2015
                    · 11 minutes read
                    · <a href="https://twitter.com/mgechev?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="true">Follow @mgechev</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                      <span class="tags">
                      
                      
                          
                              <a href="https://blog.mgechev.com/tags/immutable.js">Immutable.js</a>
                          
                              <a href="https://blog.mgechev.com/tags/javascript">JavaScript</a>
                          
                              <a href="https://blog.mgechev.com/tags/angularjs">AngularJS</a>
                          
                              <a href="https://blog.mgechev.com/tags/benchpress">Benchpress</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p>A few weeks ago I posted the article <a href="https://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/">&ldquo;Boost the Performance of an AngularJS Application Using Immutable Data&rdquo;</a>. It shows how to speedup your AngularJS application when having a lot of bindings to big data collections. The idea behind the optimization is quite simple - create a new collection when the data changes. This way you can reduce the watchers execution from <code>O(n)</code> to <code>O(1)</code>.</p>
<p>In the post I did simple profiling using the built-in <code>Date</code> but it didn&rsquo;t give enough information in exactly which cases it is more suitable to use immutable data and when you should bet on the standard collections. It also didn&rsquo;t include any information about the garbage collection, although we know that using immutable collections will eventually lead to highly intensive memory management. All the code for the benchmarks and the charts <a href="https://github.com/mgechev/benchpress-angularjs-immutable">generation is available in my GitHub account</a>.</p>
<p>On ng-conf 2015, <a href="https://www.youtube.com/watch?v=x1PJn5qMUT4">Jeff Cross, gave a talk about Benchpress</a>, which fits perfectly in my profiling purposes. Basically, benchpress uses the <a href="http://www.seleniumhq.org/projects/webdriver/">WebDriver</a> for <a href="http://www.seleniumhq.org/">Selenium</a>, through <a href="https://github.com/angular/protractor"><code>protractor</code></a> to profile your application. It can run multiple samples of the code you want to profile in order to take the mean and give you a meaningful result. It also includes a few output values, most useful in our case are:</p>
<ul>
<li><code>scriptTime</code> - the execution time of your script</li>
<li><code>gcTime</code> - time required for garbage collection of given sample</li>
</ul>
<p>Benchpress can render the output of the benchmarks as tables, printed onto the <code>stdout</code> or save it into json files.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>With every collection you can have the following primitive operations:</p>
<ul>
<li><strong>C</strong>reate collection</li>
<li><strong>R</strong>ead collection</li>
<li><strong>U</strong>pdate collection</li>
<li><strong>D</strong>elete collection</li>
</ul>
<p>We can read given collection in JavaScript or render it inside a template. If we get a new collection each time we change (update) the current one, we have an immutable collection. This means that if we want to check if the collection have changed compared to the last time we&rsquo;ve seen it we simply need to compare the current reference of the collection with the previous one (before the change was made):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">let</span> <span class="nx">changed</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span> <span class="o">===</span> <span class="nx">changed</span><span class="p">);</span> <span class="c1">// false
</span></code></pre></div>
<h3 id="side-note">Side note</h3>
<p>*But what if:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">function</span> <span class="nx">changeA</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">oldA</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
<span class="nx">changeA</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="nx">oldA</span><span class="p">);</span> <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">angular</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">oldA</span><span class="p">));</span> <span class="c1">// true
</span></code></pre></div>
<p>So, if we strictly want to perform given action <strong>only</strong> when the structure of the collection or the data inside it have changed (not only the reference) we will need to loop over both collections (old one and new one) and check whether they contains the same data.*</p>
<p>If we delete, update or create additional entries in the collection, this is considered as update. If we use immutable data, a new collection will be returned on each such manipulation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

<span class="c1">// update
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span> <span class="o">===</span> <span class="nx">list1</span><span class="p">);</span> <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 1, 2, 3 ]
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 1, 42, 3 ]
</span><span class="c1"></span>
<span class="c1">// remove
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span> <span class="o">===</span> <span class="nx">list2</span><span class="p">);</span> <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 1, 2, 3 ]
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 2, 3 ]
</span><span class="c1"></span>
<span class="c1">// insert (create entry)
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">list3</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span> <span class="o">===</span> <span class="nx">list3</span><span class="p">);</span> <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 1, 2, 3 ]
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list3</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [ 1, 2, 3, 4 ]
</span></code></pre></div>
<p>That said, we can build a sample script, which will be used for profiling. Initially we will create a single collection and attach watchers to it. Once this is done, <code>protractor</code> will start clicking a button, which will update a random element of the collection. Here is our <code>SampleCtrl</code>, which is responsible for initialization and handling the update requests:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">benchmarks</span> <span class="o">=</span> <span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;benchmarks&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;immutable&#39;</span><span class="p">]);</span>

<span class="kd">function</span> <span class="nx">SampleCtrl</span><span class="p">(</span><span class="nx">$scope</span><span class="p">,</span> <span class="nx">$location</span><span class="p">)</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dataSize</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">$location</span><span class="p">.</span><span class="nx">search</span><span class="p">().</span><span class="nx">dataSize</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">bindingsCount</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">$location</span><span class="p">.</span><span class="nx">search</span><span class="p">().</span><span class="nx">bindingsCount</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">watchers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">immutable</span><span class="o">:</span> <span class="p">[],</span>
    <span class="nx">standard</span><span class="o">:</span> <span class="p">[]</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">addWatchers</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">collection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">collection</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">$scope</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">$scope</span><span class="p">[</span><span class="nx">expr</span><span class="p">];</span>
      <span class="p">},</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="p">},</span> <span class="kc">false</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">addCollectionWatchers</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">collection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">collection</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">$scope</span><span class="p">.</span><span class="nx">$watchCollection</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="p">}));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">clearWatchers</span><span class="p">(</span><span class="nx">watchers</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">listeners</span> <span class="o">=</span> <span class="nx">watchers</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">listeners</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">l</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// Math.random() returns element in the interval [0, 1)
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">generateRandomIndx</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Updates the current value of the `standard` collection
</span><span class="c1"></span>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">updateStandard</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">$scope</span><span class="p">.</span><span class="nx">standard</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">$scope</span><span class="p">.</span><span class="nx">standard</span> <span class="o">=</span> <span class="nx">generateData</span><span class="p">(</span><span class="nx">dataSize</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">generateRandomIndx</span><span class="p">(</span><span class="nx">dataSize</span><span class="p">);</span>
      <span class="nx">$scope</span><span class="p">.</span><span class="nx">standard</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// Updates the current value of the `immutable` collection
</span><span class="c1"></span>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">updateImmutable</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">$scope</span><span class="p">.</span><span class="nx">immutable</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">$scope</span><span class="p">.</span><span class="nx">immutable</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">(</span><span class="nx">generateData</span><span class="p">(</span><span class="nx">dataSize</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// We can cache the plain collection here
</span><span class="c1"></span>      <span class="kd">var</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">generateRandomIndx</span><span class="p">(</span><span class="nx">dataSize</span><span class="p">);</span>
      <span class="nx">$scope</span><span class="p">.</span><span class="nx">immutable</span> <span class="o">=</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">immutable</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// In case we are running benchmark, which changes the array
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">$location</span><span class="p">.</span><span class="nx">search</span><span class="p">().</span><span class="nx">testType</span> <span class="o">===</span> <span class="s1">&#39;update&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dataType</span> <span class="o">=</span> <span class="nx">$location</span><span class="p">.</span><span class="nx">search</span><span class="p">().</span><span class="nx">dataType</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">dataType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="s1">&#39;immutable&#39;</span><span class="o">:</span>
        <span class="nx">addWatchers</span><span class="p">(</span><span class="nx">dataType</span><span class="p">,</span> <span class="nx">bindingsCount</span><span class="p">,</span> <span class="nx">watchers</span><span class="p">.</span><span class="nx">immutable</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="nx">addCollectionWatchers</span><span class="p">(</span><span class="nx">dataType</span><span class="p">,</span> <span class="nx">bindingsCount</span><span class="p">,</span> <span class="nx">watchers</span><span class="p">.</span><span class="nx">standard</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Clears the `immutable` collection and removes all
</span><span class="c1"></span>  <span class="c1">// listeners attached to it (except ng-repeat in the template).
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">clearImmutable</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$scope</span><span class="p">.</span><span class="nx">immutable</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">clearWatchers</span><span class="p">(</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">immutable</span><span class="p">);</span>
    <span class="nx">watchers</span><span class="p">.</span><span class="nx">immutable</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>

  <span class="c1">// Clears the `standard` collection and removes all
</span><span class="c1"></span>  <span class="c1">// listeners attached to it (except ng-repeat in the template).
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">clearStandard</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$scope</span><span class="p">.</span><span class="nx">standard</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">clearWatchers</span><span class="p">(</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">standard</span><span class="p">);</span>
    <span class="nx">watchers</span><span class="p">.</span><span class="nx">standard</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>

  <span class="c1">// Clears the both collections and all attached listeners to them.
</span><span class="c1"></span>  <span class="nx">$scope</span><span class="p">.</span><span class="nx">clear</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">clearStandard</span><span class="p">();</span>
    <span class="nx">clearImmutable</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">benchmarks</span>
  <span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;SampleCtrl&#39;</span><span class="p">,</span> <span class="nx">SampleCtrl</span><span class="p">)</span></code></pre></div>
<p>And the template&hellip;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span> <span class="na">data-ng-app</span><span class="o">=</span><span class="s">&#34;benchmarks&#34;</span> <span class="na">data-ng-controller</span><span class="o">=</span><span class="s">&#34;SampleCtrl&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;clear-btn&#34;</span> <span class="na">data-ng-click</span><span class="o">=</span><span class="s">&#34;clear()&#34;</span><span class="p">&gt;</span>Clear<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;update-immutable-btn&#34;</span> <span class="na">data-ng-click</span><span class="o">=</span><span class="s">&#34;updateImmutable()&#34;</span><span class="p">&gt;</span>
    Update Immutable
  <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;update-standard-btn&#34;</span> <span class="na">data-ng-click</span><span class="o">=</span><span class="s">&#34;updateStandard()&#34;</span><span class="p">&gt;</span>
    Update Standard
  <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">li</span> <span class="na">data-ng-repeat</span><span class="o">=</span><span class="s">&#34;item in immutable | immutable track by $index&#34;</span> <span class="na">data-ng-bind</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">li</span> <span class="na">data-ng-repeat</span><span class="o">=</span><span class="s">&#34;item in standard track by $index&#34;</span> <span class="na">data-ng-bind</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/node_modules/angular/angular.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/node_modules/immutable/dist/immutable.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/node_modules/angular-immutable/dist/immutable.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/js/app.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span></code></pre></div>
<p>There are three main variables, which has the strongest impact over such benchmark in AngularJS:</p>
<ul>
<li>type of the collection (mutable, immutable)</li>
<li>size of the collection</li>
<li>count of the bindings added to the collection</li>
</ul>
<p>In order to get clear understanding of what bindings count and collection size should make us prefer <code>Immutable.js</code> over the standard collections, I run the benchmarks with the following collections' sizes: <code>5, 10, 20, 50, 100, 500, 1000, 2000, 5000, 10000, 100000</code> and bindings count: <code>5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100</code>.</p>
<p><strong>Application with 100 bindings might sounds not realistic to you but keep in mind that AngularJS adds bindings for (almost) all directives in your templates (<code>ng-hide</code>, <code>ng-show</code>, <code>ng-bind</code>, <code>ng-repeat</code>, <code>ng-class</code>, <code>ng-model</code>, etc.). Each <code>$digest</code> loop will lead to traversal of your data structures. For more information on this topic review the AngularJS source code or watch <a href="https://www.youtube.com/watch?v=wbcJfg-d5nI">&ldquo;Sasqwatch is Real&rdquo; by William Scott Moss</a>.</strong></p>
<h2 id="results-representation">Results Representation</h2>
<p>So far so good. The only thing left is to configure benchpress but this is pretty much a straightforward process. You can find my configuration scripts <a href="https://github.com/mgechev/benchpress-angularjs-immutable/tree/master/benchmarks">here</a> and Jeff&rsquo;s <a href="https://github.com/jeffbcross/benchpress-tree">here</a>. Note that it is not required to use benchpress with Angular, you can use it with any other framework or even without one.</p>
<p>After you&rsquo;ve successfully configured benchpress and start protractor you should see something like:</p>
<p><img src="/images/boost-angularjs-immutable-data/protractor-running.gif" alt=""></p>
<p>After we run the benchmarks and set the output directory, all the logs will be saved in there, in json format. What we can do is to aggregate the raw results (for example get the mean) and output them in another file or print them on the screen. This seems fine but visual representation is always better. For rendering the data as charts I used node.js with <a href="https://github.com/Automattic/node-canvas"><code>node-canvas</code></a>. Later I found that there&rsquo;s a <a href="https://www.npmjs.com/package/nchart">&ldquo;hacked&rdquo; version of Chart.js, which could be run in node</a>. The glue code for rendering benchpress logs onto Chart.js charts seems generic enough and it may get handy to anyone else, so next couple of weeks I may publish it as npm module.</p>
<h2 id="exploring-the-results">Exploring the Results</h2>
<p>The results contain the script running time and the garbage collection time, mostly because of the immutable data.</p>
<h3 id="script-time">Script Time</h3>
<p>This metric will have the strongest impact on the application&rsquo;s performance, since the script time is single threaded. On the charts below are illustrated the script metrics concerning the script running time of the benchmarks above. The horizontal axis (x-axis) shows the bindings count and the vertical axis (y-axis) illustrates the script running time (in ms).</p>
<h4 id="5-entries">5 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-5.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-5.png" alt="5 entries"></a></p>
<p>When having a collection with 5 entries the running time of the script using immutable list is almost double the running time of a standard array. When the bindings counts get bigger there are no significant changes in the time required for running the scripts (both immutable and standard array).
Basically when we have 100 bindings (+1 with the watcher added by <code>ng-repeat</code>) the AngularJS change detection mechanism needs to perform 5 * 100 iterations (in the worst case) in order to verify that the current value of the array is equals to the previous one for the standard array and a 100 comparisons (one for each binding using <code>===</code>) in order to detect changes in the immutable data. Since we have overhead caused by the creation of new immutable list on change, the running time of the script using immutable data is bigger.</p>
<h4 id="20-entries">20 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-20.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-20.png" alt="20 entries"></a></p>
<p>There are no significant changes in the results of the benchmark, which runs script with array/list with 20 entries. The only noticeable difference here is that the running time of the script using standard array gets significantly bigger when we increase the bindings count. Again, when we have 100 bindings and 20 element array we get 20 * 100 iterations in order to detect change, compared to 20 * 5 with only 5 bindings.</p>
<h4 id="50-entries">50 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-50.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-50.png" alt="50 entries"></a></p>
<p>This is the first benchmark, which results show better performance of the immutable list compared to the standard one. In case of 100 bindings the immutable list wins!</p>
<h4 id="100-entries">100 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-100.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-100.png" alt="100 entries"></a></p>
<p>Here the competition gets ruthless! We see how much bigger the running time of the script using standard array gets when we have large amount of bindings. Anyway, still the standard array looks like the winner.</p>
<h4 id="500-entries">500 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-500.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-500.png" alt="500 entries"></a></p>
<p>It looks like the supreme champion in this benchmark is the immutable array! You still have to watch out whether you have only a few bindings to the collection but definitely if you have more than 10 you should consider using immutable data.</p>
<h4 id="10000-entries">10,000 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/scripttime-data-size-10000.png"><img src="/images/boost-angularjs-immutable-data/scripttime-data-size-10000.png" alt="10,000 entries"></a></p>
<p>After 20 bindings the running time of the script using standard array gets crazy big! You can see how it gets bigger and bigger with every next binding, although the running time of the script using immutable list stays constant. I&rsquo;d definitely recommend you to use immutable data with such big collections.</p>
<h3 id="garbage-collection-time">Garbage Collection Time</h3>
<p><img src="/images/one-does-not-simply-profile-the-script-running-time.png" alt=""></p>
<p>This metric indicates the time required for garbage collection. I&rsquo;m exposing this metric as secondary one because the user may not notice directly the impact of the garbage collection time during her experience using our application.
It is interesting that the information we got from the benchmarks doesn&rsquo;t imply any significant advantage of the standard array compared to the immutable list.</p>
<p>I will not provide further explanation for the following sections because I think they are self explanatory. However, if you have any troubles understanding them or you think they deserve further discussions you&rsquo;re welcome to drop a line as a comment or reach me over e-mail (take a look at the <a href="https://blog.mgechev.com/about/">About</a> section above).</p>
<h4 id="5-entries-1">5 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/gctime-data-size-5.png"><img src="/images/boost-angularjs-immutable-data/gctime-data-size-5.png" alt="5 entries"></a></p>
<h4 id="50-entries-1">50 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/gctime-data-size-50.png"><img src="/images/boost-angularjs-immutable-data/gctime-data-size-50.png" alt="50 entries"></a></p>
<h4 id="100-entries-1">100 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/gctime-data-size-100.png"><img src="/images/boost-angularjs-immutable-data/gctime-data-size-100.png" alt="100 entries"></a></p>
<h4 id="500-entries-1">500 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/gctime-data-size-500.png"><img src="/images/boost-angularjs-immutable-data/gctime-data-size-500.png" alt="500 entries"></a></p>
<h4 id="10000-entries-1">1,0000 entries</h4>
<p><a href="/images/boost-angularjs-immutable-data/gctime-data-size-10000.png"><img src="/images/boost-angularjs-immutable-data/gctime-data-size-10000.png" alt="1,000 entries"></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>Some of the ideas brought to us by the functional paradigm, such as: pure functions, referential transparency, immutable data, etc. constantly find broader and broader applications in building user interface. As we explored in details in the <a href="https://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/">two parts of this blog post on using immutable data with AngularJS</a>, immutability could be quite helpful when we have a lot of bindings on a big data collection. However, in the general use case I&rsquo;d recommend usage of standard arrays.</p>
<p>The immutable data helps us speedup the watchers from <code>O(n)</code> (looping over the whole data structure) to <code>O(1)</code> (comparing only references, since on change a new immutable data structure will be created) but it also has its drawbacks:</p>
<ul>
<li>overhead of the creation of the new data structure on change</li>
<li>overhead of the performed garbage collection (which wasn&rsquo;t such a big deal, as show above)</li>
</ul>
<p>But can&rsquo;t we build something, which takes the best of both worlds? Can&rsquo;t we build a specialized data structure used for super fast data binding, which doesn&rsquo;t require creation of new instance on change but still allows <code>O(1)</code> check for change? This is what I&rsquo;m going to explore in the last blog post of this series.</p>
<h2 id="parts-of-the-series">Parts of the series:</h2>
<ul>
<li><a href="https://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/">Boost the Performance of an AngularJS Application Using Immutable Data - Part 1</a></li>
<li><a href="https://blog.mgechev.com/2015/04/11/immutability-in-angularjs-immutablejs-part-2/">Boost the Performance of an AngularJS Application Using Immutable Data - Part 2</a></li>
<li><a href="https://blog.mgechev.com/2015/04/20/fast-angular-data-structures-versionable/">Even Faster AngularJS Data Structures</a></li>
</ul>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mgechev';

     
    (function () {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    <div class="by-author">with <i class="fa fa-heart" aria-hidden="true"></i> by Minko Gechev</div>
    <p class="small">
         © Copyright 2022  
    </p>
</footer>
        </section>

        <script src="https://blog.mgechev.com/js/main.js"></script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-18060688-3', 'auto');
	
	ga('send', 'pageview');
}
</script>


<script async src="//twemoji.maxcdn.com/2/twemoji.min.js?2.3.0"></script>
<script>
  window.addEventListener('load', function () {
    twemoji.parse(document.body, { size: 72 });
  });
</script>



    </body>
</html>
