    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		<meta name="generator" content="Hugo 0.55.5" />
		<title>Static Code Analysis of Angular 2 and TypeScript Projects &middot; Minko Gechev&#39;s blog</title>
		<link rel="shortcut icon" href="https://blog.mgechev.com/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/highlight.css">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/style.css">
		

		
		<link rel="stylesheet" href="https://blog.mgechev.com/css/font-awesome.min.css">
		

		
		<link href="https://blog.mgechev.com/feed.xml" rel="alternate" type="application/rss+xml" title="Minko Gechev&#39;s blog">
		
		
		<link rel="amphtml" href="https://blog.mgechev.com/amp/2016/02/29/static-code-analysis-angular-typescript/">
		

		<meta property="og:title" content="Static Code Analysis of Angular 2 and TypeScript Projects" />
		<meta property="og:description" content="So far, most of the blog posts I&rsquo;ve written are tutorials; they explain how we can use given technologies, architectures, algorithm etc. For instance:
 Flux in Depth. Store and Network Communication. ViewChildren and ContentChildren in Angular 2 Build Your own Simplified AngularJS in 200 Lines of JavaScript Remote Desktop Client with AngularJS and Yeoman  The code for the current research could be found here and here.
The current post is about an exciting project I am working on in my spare time." />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://blog.mgechev.com/2016/02/29/static-code-analysis-angular-typescript/" />
		
		<meta property="og:image" content="https://blog.mgechev.com/images/myself.jpg"/>
		<meta property="og:image:secure_url" content="https://blog.mgechev.com/images/myself.jpg"/>
		
	</head>

    <body>
       <nav class="main-nav">
  
  <div class="link-wrapper">
	
	
		<a href='https://blog.mgechev.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blog.mgechev.com/post'>Posts</a>
	<a href='https://blog.mgechev.com/about'>About</a>
	<a href='https://blog.mgechev.com/talks'>Speaking</a>
  </div>

	

	
  
	
</nav>
<a href="https://github.com/mgechev" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="z-index: 100000; fill:#70B7FD; color:#fff; position: fixed; top: 20px; border: 0; left: 20px; transform: scale(-1.5, 1.5);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Static Code Analysis of Angular 2 and TypeScript Projects
                    </h1>
                    <h2 class="headline">
                    <a href="https://github.com/mgechev/blog.mgechev.com/tree/master/content/post/2016-02-29-static-code-analysis-angular-typescript.md">
                        <i class="fa fa-pencil-square-o"></i> Edit
                    </a>
                    · Feb 29, 2016
                    · 17 minutes read
                    · <a href="https://twitter.com/mgechev?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="true">Follow @mgechev</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                      <span class="tags">
                      
                      
                          
                              <a href="https://blog.mgechev.com/tags/javascript">JavaScript</a>
                          
                              <a href="https://blog.mgechev.com/tags/angular-2">Angular 2</a>
                          
                              <a href="https://blog.mgechev.com/tags/typescript">TypeScript</a>
                          
                              <a href="https://blog.mgechev.com/tags/parsers">Parsers</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>So far, most of the blog posts I&rsquo;ve written are tutorials; they explain how we can use given technologies, architectures, algorithm etc. For instance:</p>

<ul>
<li><a href="https://blog.mgechev.com/2015/07/18/flux-in-depth-store-network-communication-services">Flux in Depth. Store and Network Communication.</a></li>
<li><a href="https://blog.mgechev.com/2016/01/23/angular2-viewchildren-contentchildren-difference-viewproviders">ViewChildren and ContentChildren in Angular 2</a></li>
<li><a href="https://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs">Build Your own Simplified AngularJS in 200 Lines of JavaScript</a></li>
<li><a href="https://blog.mgechev.com/2014/02/08/remote-desktop-vnc-client-with-angularjs-and-yeoman/">Remote Desktop Client with AngularJS and Yeoman</a></li>
</ul>

<p><em>The code for the current research could be found <a href="https://github.com/mgechev/ng2lint/tree/master">here</a> and <a href="https://github.com/mgechev/ng2lint/tree/advanced">here</a>.</em></p>

<p>The current post is about an exciting project I am working on in my spare time. A few days ago I <a href="https://blog.mgechev.com/2016/02/18/angular2-style-guide-best-practices-lint-tslint">explained my motivation</a> behind the <a href="https://github.com/mgechev/angular2-style-guide">&ldquo;Community-drive Style Guide&rdquo; for Angular 2</a> that we&rsquo;re working on. I also mentioned that I am planning to build a configurable static-code analyzer, which makes sure given project follows best practices and contains &ldquo;correct&rdquo; Angular 2 code. I called this project <a href="https://github.com/mgechev/ng2lint"><code>ng2lint</code></a>.</p>

<p>In this article I will explain the main goals of the project, as well as its core challenges and possible solutions. I will also show my current progress. Lets start with the main goals:</p>

<h3 id="following-style-guidelines">Following Style guidelines</h3>

<p>We can make sure given project follows some predefined style guidelines by using a standard <a href="https://en.wikipedia.org/wiki/Lint_(software)">linting</a>, such as the one introduced by <a href="https://palantir.github.io/tslint/">tslint</a>. The Angular 2 Style Guide provides a sample <a href="https://github.com/mgechev/angular2-style-guide#tslint"><code>tslint</code> configuration file</a>, which can be used.</p>

<p>As extension of the functionality provided by <code>tslint</code> the <a href="https://github.com/mgechev/ng2lint"><code>ng2lint</code>er</a> should introduce file name validation, based on the conventions defined in the style guide.</p>

<h3 id="following-the-best-practices">Following the Best Practices</h3>

<p>Although in most cases there&rsquo;s a good understanding of what best practices are, some of them, especially the ones related to coding style, on big extent depend on personal preferences. This means that a universal static-code analyzer should be configurable.</p>

<p>For instance, according to best practices described in the <a href="https://github.com/mgechev/angular2-style-guide">Angular 2 style guide</a> directives should be used as attributes and components should be used as elements. However, in a legacy project which uses different naming we should be able to bend <code>ng2lint</code> to adjust the project&rsquo;s specific conventions.</p>

<h3 id="verifying-program-correctness">Verifying Program Correctness</h3>

<p>By saying correct I mean that the project follows some rules, which are enforced by the Angular framework and without following these rules our Angular application will has a run-time error. Using static code analysis we can verify that:</p>

<ul>
<li>All pipes used inside the templates are declared.</li>
<li>All custom attributes of elements in the templates are declared as either inputs, outputs or directives.</li>
<li>All identifiers used are inlined in the template expressions exist in the corresponding symbol table (which in the context of Angular is the instance of the component associated to the template).</li>
<li>etc.</li>
</ul>

<h3 id="usage-out-of-the-box">Usage out-of-the box</h3>

<p><code>ng2lint</code> is supposed to work with the current tools provided by the ecosystem that developers use. This means that in order to see warnings in your favorite IDE or text editor you should not be supposed to develop a custom plugin.</p>

<h3 id="performance">Performance</h3>

<p>Performance is an important characteristic. In the perfect scenario <code>ng2lint</code> should run its validators for just a few seconds over a big and complex project.</p>

<h3 id="out-of-scope">Out of Scope</h3>

<p>Since TypeScript is a statically typed language it already provides some extent of type-safety. This means that huge part of the code&rsquo;s validation is responsibility of the TypeScript compiler. It will slap our hands in case we&rsquo;ve misspell an identifier name or keyword.</p>

<h3 id="benefits-of-ng2lint">Benefits of <code>ng2lint</code></h3>

<p>Project like this will allow us to receive text editor/IDE warnings for:</p>

<ul>
<li>Not following best practices for Angular 2 application development.</li>
<li>Not following style guidelines our team has agreed upon.</li>
<li>Incorrect Angular 2-specific code.</li>
</ul>

<h2 id="crash-course-in-parsing">Crash Course in Parsing</h2>

<p>In order to have better understanding of the up following sections we need to make a quick introduction to parsing, which is core concept in the compiler&rsquo;s design and implementation.</p>

<p>The input of any compiler is a file which contains a text that needs to be processed. Two top-level goals of each compiler are to:</p>

<ul>
<li>Verify whether the input program belongs to the programming language defined with given <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">grammar</a>.</li>
<li>Execute the program or translate it to a target format.</li>
</ul>

<p>For our purpose we are interested only in the first goal, which is part of the front-end of the compiler.</p>

<p>Before explaining the challenges and the current results I got in <code>ng2lint</code>, let make a quick overview of how the front-end of a compiler works. The modules we&rsquo;re going to explain are:</p>

<ul>
<li>Lexer</li>
<li>Parser</li>
</ul>

<h3 id="grammars">Grammars</h3>

<p>Grammars allow us to define a set of abstract rules for construction of strings. The set of all strings generated using given grammar is the set of all programs for given programming language. The set of all programs for given programming language is the actual programming language.</p>

<p>This abstract explanation will get more clear in the end of this section. You can read more about <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammars here</a>.</p>

<h3 id="introducing-the-lexer">Introducing the Lexer</h3>

<p>The main purpose of the lexer (a.k.a. tokenizer, scanner) is to take the input character stream and output a stream of tokens. Each token has a &ldquo;lexeme&rdquo; which is the actual substring of the program and a &ldquo;type&rdquo;.</p>

<p>For instance, lets take a look at the following program:</p>
<div class="highlight"><pre class="chroma">if (1) {
  if (0) {
    42 + 12 + 2
  }
  2 + 3
}</pre></div>
<p>We can implement our parser so it returns an array of JavaScript object, each of which represent an individual token. The first a couple of tokens are going to be:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="p">[</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;if&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;keyword&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">line</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="kr">char</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;open_bracket&#39;</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">line</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="kr">char</span><span class="o">:</span> <span class="mi">3</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">line</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="kr">char</span><span class="o">:</span> <span class="mi">4</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;)&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;close_bracket&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">line</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="kr">char</span><span class="o">:</span> <span class="mi">5</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">...</span>
<span class="p">]</span>
</code></pre></div>
<p>If you are interested in further reading about lexical analysis I&rsquo;d recommend you to get familiar with:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite Automata</a></li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular Expressions</a></li>
</ul>

<h3 id="parsing">Parsing</h3>

<p>Now we have a stream of tokens. For a <a href="https://en.wikipedia.org/wiki/Syntax-directed_translation">syntax-directed compilers</a> this could be enough. However, in most cases we need to build an intermediate representation of the program which brings more semantics and is easier to process by the back-end of the compiler. As input for creating this intermediate representation the parser uses the token stream we got from the lexer and the grammar associated to the programming language.</p>

<p>The process of developing lexers and parsers usually contains the same repetitive steps across compilers for different languages so that is why there are tools which allow you to generate the code for these two modules based on given grammar.</p>

<p>Deep-dive in parsing is out of the scope of the current article but lets tell a few words about the basics. What is this &ldquo;intermediate representation&rdquo; that the parser builds based on the token stream and the language&rsquo;s grammar? Well, it builds a tree, more accurately an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (<strong>AST</strong>).</p>

<p>Lets take a look at the AST of the program above:</p>

<p><img src="/images/ast.png" alt="AST" /></p>

<p>In case you&rsquo;re interested in further reading about parsers, take a look at the following resources:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free grammars</a></li>
<li><a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">Extended Backus–Naur Form</a></li>
<li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax trees</a></li>
</ul>

<h3 id="one-more-step">One more step&hellip;</h3>

<p>We&rsquo;re almost done with the theory behind <code>ng2lint</code>. In this final step of the &ldquo;Crash Course in Parsing&rdquo; we will just peek at the back-end of any compiler by introducing a classical design pattern which is exclusively used there.</p>

<blockquote>
<p>In object-oriented programming and software engineering, the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor design pattern</a> is a way of separating an algorithm from an object structure on which it operates.</p>
</blockquote>

<p>How we can use this pattern in order to interpret the program we defined above, using its intermediate AST representation? We want to have different algorithms for processing the AST, for instance:</p>

<ul>
<li>Interpretation of the AST</li>
<li>Code generation</li>
<li>Static code analysis</li>
</ul>

<p>This means that the visitor pattern is perfect for this purpose - we will develop an algorithm for processing the AST but we won&rsquo;t couple it with any of these algorithms.</p>

<p>Here&rsquo;s how we can develop a visitor for this purpose:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kr">class</span> <span class="nx">InterpretationVisitor</span> <span class="p">{</span>
  <span class="nx">execute</span><span class="p">(</span><span class="nx">ast</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ast</span><span class="p">.</span><span class="nx">statements</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">visitNode</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="nx">visitNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="s1">&#39;if_statement&#39;</span><span class="o">:</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">visitIfStatement</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">&#39;expression&#39;</span><span class="o">:</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">visitExpression</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Unrecognized node&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">visitIfStatement</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">visitNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">condition</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">statements</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">visitNode</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">visitExpression</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">operator</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">visitNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">visitNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Now all we have to do in order to interpret the program is:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">let</span> <span class="nx">visitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">InterpretationVisitor</span><span class="p">();</span>
<span class="nx">visitor</span><span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span></code></pre></div>
<p><a href="https://github.com/palantir/tslint"><code>tslint</code></a> for instance, uses similar approach for the implementation of the rules it provides.</p>

<p>Lets peek at a sample rule definition:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">ts</span> <span class="nx">from</span> <span class="s1">&#39;typescript&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">Lint</span> <span class="nx">from</span> <span class="s1">&#39;../lint&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">class</span> <span class="nx">Rule</span> <span class="kr">extends</span> <span class="nx">Lint</span><span class="p">.</span><span class="nx">Rules</span><span class="p">.</span><span class="nx">AbstractRule</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="kr">static</span> <span class="nx">FAILURE_STRING</span> <span class="o">=</span> <span class="s2">&#34;type decoration of &#39;any&#39; is forbidden&#34;</span><span class="p">;</span>

    <span class="kr">public</span> <span class="nx">apply</span><span class="p">(</span><span class="nx">sourceFile</span>: <span class="kt">ts.SourceFile</span><span class="p">)</span><span class="o">:</span> <span class="nx">Lint</span><span class="p">.</span><span class="nx">RuleFailure</span><span class="p">[]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">applyWithWalker</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Lint</span><span class="p">.</span><span class="nx">RuleWalker</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="nx">NoAnyWalker</span><span class="p">(</span><span class="nx">sourceFile</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">getOptions</span><span class="p">())));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">NoAnyWalker</span> <span class="kr">extends</span> <span class="nx">Lint</span><span class="p">.</span><span class="nx">RuleWalker</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="nx">visitAnyKeyword</span><span class="p">(</span><span class="nx">node</span>: <span class="kt">ts.Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">addFailure</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">createFailure</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">getStart</span><span class="p">(),</span> <span class="nx">node</span><span class="p">.</span><span class="nx">getWidth</span><span class="p">(),</span> <span class="nx">Rule</span><span class="p">.</span><span class="nx">FAILURE_STRING</span><span class="p">));</span>
        <span class="kr">super</span><span class="p">.</span><span class="nx">visitAnyKeyword</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>In the snippet above we have definition of two classes:</p>

<ul>
<li><code>Rule</code> - <code>tslint</code> uses TypeScript&rsquo;s compiler for generation of the AST of each file in given project. Once the AST is available, <code>tslint</code> passes it to the <code>apply</code> method of each rule.</li>
<li><code>NoAnyWalker</code> - a visitor which extends the <code>RuleWalker</code> class that provides some features, such as <code>createFailure</code>, <code>addFailure</code>, etc. The <code>NoAnyWalker</code> overrides the definition of the <code>visitAnyKeyword</code> method and reports a failure once it finds &ldquo;<code>any</code> decorations&rdquo;.</li>
</ul>

<p>For instance:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">let</span> <span class="nx">foo</span>: <span class="kt">any</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span></code></pre></div>
<p>Will fail with <code>type decoration of 'any' is forbidden</code>.</p>

<h2 id="challenges-in-ng2lint">Challenges in <code>ng2lint</code></h2>

<p>Now lets take a look at the goals we defined earlier and see how we can take advantage of already know in order to achieve them.</p>

<h3 id="usage-out-of-the-box-1">Usage out-of-the box</h3>

<p>The way to achieve this goal is to reuse the error reporting mechanism of existing, popular tool. <code>tslint</code> is already widely supported by most IDEs and text editors that are popular in the Angular&rsquo;s community. If <code>ng2lint</code> uses its error reporting mechanism the IDEs/text editors that support <code>tslint</code> will support <code>ng2lint</code> as well.</p>

<h3 id="following-style-guidelines-following-the-best-practices">Following Style guidelines &amp; Following the Best Practices</h3>

<p>We can achieve this goal by using <code>tslint</code> as well. Verifying that given source file follows defined style guidelines involves static code analysis similar to the one performed by the rules declared by <a href="https://github.com/palantir/tslint/blob/master/src/rules/"><code>tslint</code></a> and the <a href="https://github.com/palantir/tslint#custom-rule-sets-from-the-community">ones developed by the community</a>.</p>

<h3 id="verifying-program-correctness-1">Verifying Program Correctness</h3>

<p>This is the most challenging part of <code>ng2lint</code> because of the following reasons:</p>

<ul>
<li>TypeScript does not parses the Angular 2 templates.</li>
<li>There is extra semantics on top of TypeScript introduced by Angular 2.</li>
<li>There are externalized templates which need to be loaded from disk.</li>
<li>There are definitions of directives and components which need to be resolved.</li>
<li>The process is slow so parsing should be performed only over the changed code.</li>
</ul>

<p>Lets discuss approaches for handling some of these challenges.</p>

<h4 id="typescript-does-not-parses-the-angular-templates">TypeScript does not parses the Angular templates</h4>

<p>Suppose we have the following component definition:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;custom-heading&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;h1&gt;{{heading}}&lt;/h1&gt;&#39;</span>
<span class="p">})</span>
<span class="kr">class</span> <span class="nx">CustomHeadingComponent</span> <span class="p">{</span>
  <span class="nx">heading</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>Once TypeScript&rsquo;s compiler parses Angular program the AST will look something like:</p>

<p><img src="/images/ng2ast.png" alt="Simple TypeScript AST of Angular program" /></p>

<p>Notice the red node in the bottom-right - it is the initializer of the second key-value pair from the object literal that we pass to the <code>@Component</code> decorator.</p>

<p>Since it is not responsibility of TypeScript to parse Angular&rsquo;s templates it only holds their string representations, or in case of <code>templateUrl</code> their paths.</p>

<p>Fortunately, Angular 2 exposes its <code>TemplateParser</code>. Thanks to Angular&rsquo;s platform agnostic implementation and <a href="https://github.com/inikulin/parse5">parse5</a>, <code>TemplateParser</code> could be used in node environment.
It allows us to parse the templates of our components using the following API:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">let</span> <span class="nx">parser</span>: <span class="kt">TemplateParser</span> <span class="o">=</span> <span class="nx">injector</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">TemplateParser</span><span class="p">);</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">templateString</span><span class="p">,</span> <span class="nx">directivesList</span><span class="p">,</span> <span class="nx">pipesList</span><span class="p">,</span> <span class="nx">templateUrl</span><span class="p">);</span></code></pre></div>
<p>The first argument of the <code>parse</code> method of the parser is the template of the component. As second argument we need to pass the list of the directives and pipes visible by the component (this includes the list of directives/pipes declared in the <code>directives</code>/<code>pipes</code> property of <code>ComponentMetadata</code> as well as all other directives/pipes declared in the same way in parent components). In our case we don&rsquo;t need to pass any value for <code>templateUrl</code> since the template is used inline.</p>

<p>In case <code>CustomHeadingComponent</code> is a top-level component we can parse its template with:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;&lt;h1&gt;{{heading}}&lt;/h1&gt;&#39;</span><span class="p">,</span> <span class="nx">COMMON_DIRECTIVES</span><span class="p">,</span> <span class="nx">COMMON_PIPES</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span></code></pre></div>
<p>The <code>parse</code> method will return an <code>HtmlAst</code> which can be validated with visitor, similar to the one we use for validation of the TypeScript code.</p>

<h4 id="definitions-of-directives-and-components-which-need-to-be-resolved">Definitions of directives and components which need to be resolved</h4>

<p>Now lets suppose we have the following components definitions:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">// cmp_a.ts
</span><span class="c1"></span><span class="kr">import</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@angular/core&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">B</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./cmps_b_c&#39;</span><span class="p">;</span>

<span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
  <span class="nx">templateUrl</span><span class="o">:</span> <span class="s1">&#39;./a.html&#39;</span><span class="p">,</span>
  <span class="nx">directives</span><span class="o">:</span> <span class="p">[</span><span class="nx">B</span><span class="p">]</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">// cmps_b_c.ts
</span><span class="c1"></span><span class="kr">import</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@angular/core&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">D</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./dir_d&#39;</span><span class="p">;</span>

<span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">C</span> <span class="p">{}</span>

<span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;c&gt;&lt;/c&gt;&lt;div d&gt;&lt;/div&gt;&#39;</span><span class="p">,</span>
  <span class="nx">directives</span><span class="o">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">,</span> <span class="nx">C</span><span class="p">],</span>
  <span class="nx">inputs</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">B</span> <span class="p">{}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">// dir_d.ts
</span><span class="c1"></span><span class="kr">import</span> <span class="p">{</span><span class="nx">Directive</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@angular/core&#39;</span><span class="p">;</span>

<span class="kd">@Directive</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;[d]&#39;</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">D</span> <span class="p">{}</span></code></pre></div>
<p>Lets suppose we want to validate the template of component <code>B</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;&lt;c&gt;&lt;/c&gt;&lt;div d&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="nx">COMMON_DIRECTIVES</span><span class="p">,</span> <span class="nx">COMMON_PIPES</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span></code></pre></div>
<p>The parser will throw an error similar to:</p>
<div class="highlight"><pre class="chroma">Template parse errors:
The element &#39;div&#39; does not have a native attribute &#39;d&#39;.</pre></div>
<p>This happens because we haven&rsquo;t included the directive <code>D</code> in the array we pass as second argument to <code>parse</code>.</p>

<p>This means that we need to create a context specific for each of the components in the component tree which includes the visible by the component directives and pipes.
In case we want to validate the entire component tree what we need to do is to validate each of the components in their own context. Before doing this, similarly to the AST that the parsers build, we need to create an intermediate representation of the entire component tree.</p>

<p>Lets track the process of building the component tree&rsquo;s intermediate representation:</p>

<ul>
<li>Gather metadata for directive.

<ul>
<li>TypeScript generates AST for the directive.</li>
<li>Based on the AST we create an intermediate Angular specific directive representation.</li>
<li>We collect the <code>selector</code>, <code>template</code>, <code>inputs</code>, <code>outputs</code>, etc.</li>
<li>If this directive is not a component return the data collected so far.</li>
<li>We collect all <code>directives</code> (note that the directives here are actually references to other classes).

<ul>
<li>Find the file which contains the definition of the target directive.</li>
<li>Gather metadata for the directive (notice that this is a recursive call to &ldquo;Gather metadata for directive&rdquo; and there could be cyclic dependencies).</li>
<li>Add the directive with its entire sub tree to the directives array of the component.</li>
</ul></li>
<li>We collect all <code>pipes</code> (note that the pipes here are actually references to other classes).

<ul>
<li>Find the file which contains the definition of the target pipe.</li>
<li>Gather metadata for the pipe.</li>
<li>Add the pipe to the pipes array of the component.</li>
</ul></li>
</ul></li>
</ul>

<p>Alright, now we are done. There are two things to note here:</p>

<ul>
<li>There could be cyclic dependencies between components which are typically resolved with <code>forwardRef</code>.</li>
<li>There are a lot of disk I/O operations because the directives used by any component are most likely located in different files.</li>
</ul>

<p>We will see what we can do for the I/O operations in the section: &ldquo;Externalized templates which need to be loaded from disk&rdquo;, which is generic and could be applied for templates as well as for directives.</p>

<p>Once we&rsquo;ve gathered useful information for the component tree, lets introduce the algorithm which can be applied for validation:</p>

<ul>
<li>Validate given directive.</li>
<li>If the directive is not a component return.</li>
<li>Use the parser in order to get the AST of the component&rsquo;s template (we already have validation for pipes and directives thanks to the parser of Angular. It will throw an error in case it doesn&rsquo;t find any of the used custom attributes and pipes).

<ul>
<li>Validate template&rsquo;s expressions.</li>
<li>Validate component&rsquo;s directives (recursive call).</li>
</ul></li>
</ul>

<h5 id="validation-of-template-expressions">Validation of Template Expressions</h5>

<p>The final thing left here is the procedure for validation of the template&rsquo;s expressions. Why we haven&rsquo;t solved this yet?</p>

<p>Lets take a look at the following component:</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;custom-cmp&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;h1&gt;{{foo + bar}}&lt;/h1&gt;&#39;</span>
<span class="p">})</span>
<span class="kr">class</span> <span class="nx">CustomComponent</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">;</span>
  <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>If we parse this source file using TypeScript&rsquo;s parser and after that we parse its template by using Angular&rsquo;s <code>TemplateParser</code> we will get:</p>

<p><img src="/images/ng2ast_html.png" alt="AST of Angular component with parsed template" /></p>

<p>On the image above we can see two ASTs merged together:</p>

<ul>
<li>The TypeScript AST generated by TypeScript&rsquo;s compiler.</li>
<li>The Angular template&rsquo;s AST generated by Angular&rsquo;s <code>TemplateParser</code>.</li>
</ul>

<p>The problem now is that although we&rsquo;ve parsed both the source file and the template, we haven&rsquo;t parsed the Angular expression. Angular defines a small DSL which allows us to execute different expressions in the context of given component.</p>

<p>In order to verify that the above expression <code>{{foo + bar}}</code> could be invoked in the context of <code>CustomComponent</code> we need to go through another process of parsing. For this purpose we can use Angular&rsquo;s parser defined under <code>core/change_detection/parser/parser.ts</code>.</p>

<p>We need to get reference to its instance and parse the expression. After that we&rsquo;ll get the following mixture of ASTs:</p>

<p><img src="/images/ng2ast_html_expr.png" alt="AST of Angular component with parsed template and template expressions" /></p>

<p>Now, at this point, we can traverse the bottom most AST and see whether the identifiers there exist in the corresponding symbol table (which is the instance of the <code>CustomComponent</code> controller).</p>

<h4 id="externalized-templates-which-need-to-be-loaded-from-disk">Externalized templates which need to be loaded from disk</h4>

<p>Now lets suppose instead of <code>template</code> our component uses <code>templateUrl</code>. This means that the validator need to read the template from the disk, in a directory (usually) relative to the component&rsquo;s definition.</p>

<p>The disk I/O operations are slow:</p>
<div class="highlight"><pre class="chroma">Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy             3,000   ns        3 us
Send 1K bytes over 1 Gbps network       10,000   ns       10 us
Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD
Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</pre></div>
<p>This means that in the perfect scenario we want to read external templates from the disk <strong>only</strong> when they change. This could be achieved with something like <a href="https://nodejs.org/docs/latest/api/fs.html"><code>fs.watch</code></a> or any of its high-level wrappers. Once a change is discovered, this need to update <strong>only</strong> the impacted region.</p>

<h2 id="current-progress">Current Progress</h2>

<p>A few weeks ago I developed a few rules for <code>tslint</code> which add some custom Angular 2 specific validation behavior. The project is located in the master branch of the <a href="https://github.com/mgechev/ng2lint"><code>ng2lint</code></a> repository.</p>

<p>According to <a href="https://www.npmjs.com/package/ng2lint"><code>npm</code></a> on average it has 150 downloads per day.</p>

<p>The rules I develop include:</p>

<ul>
<li>Directive selector type.</li>
<li>Directive selector name convention.</li>
<li>Directive selector name prefix.</li>
<li>Component selector type.</li>
<li>Component selector name convention.</li>
<li>Component selector name prefix.</li>
<li>Use <code>@Input</code> instead of inputs decorator property.</li>
<li>Use <code>@Output</code> instead of outputs decorator property.</li>
<li>Use <code>@HostListeners</code> and <code>@HostBindings</code> instead of host decorator property.</li>
<li>Do not use the @Attribute decorator (implemented by <a href="https://github.com/PreskoIsTheGreatest">PreskoIsTheGreatest</a>).</li>
</ul>

<p>Possible improvement here is extension of the default walkers that we already have with <code>AngularRuleWalker</code>. For instance adding operations such as:</p>

<ul>
<li><code>visitDirectiveMetadata</code></li>
<li><code>visitComponentMetadata</code></li>
<li><code>visitHostListener</code></li>
<li>etc.</li>
</ul>

<p>could save us form a lot of boilerplate code in <code>ng2lint</code>.</p>

<p>Another possible extension is validation of the file names we lint based on a semantics gathered from the file&rsquo;s content.</p>

<p>For instance, if we find out that inside of given file there&rsquo;s definition of a component we can validate that the file name follows the name convention:</p>
<div class="highlight"><pre class="chroma">NAME.component.ts</pre></div>
<p>The last weekend I spend playing with more advanced implementation of the linter which aims validation for correctness. The entire progress is located in the <a href="https://github.com/mgechev/ng2lint/tree/advanced/">advanced branch of <code>ng2lint</code></a>.</p>

<p>In this branch I implemented the following:</p>

<ul>
<li>Building in-memory intermediate representation of the component tree.</li>
<li>Reads externalized templates from disk.</li>
<li>Recursively validating components&rsquo; templates for missing pipes/directives declared for given sub tree.</li>
<li>Parsing component&rsquo;s templates.</li>
</ul>

<p>Tasks pending are:</p>

<ul>
<li>Parse the inlined expressions and verify that all the identifiers are defined.</li>
<li>Integrate both tools together. This will allow the &ldquo;validating correctness module&rdquo; to use the error reporting mechanism of <code>tslint</code> and work out of the box with editors like VSCode, WebStorm, etc.</li>
<li>Handle cyclic references.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The process of building a complete linter for Angular 2 is quite challenging because of several reasons:</p>

<ul>
<li>Computational intensity.</li>
<li>Various intermediate code representations.</li>
<li>Integration with the existing compiler of TypeScript.</li>
<li>Integration with existing linters such as <code>tslint</code> for working out of the box error reporting mechanism.</li>
</ul>

<p>Fortunately, neither of the challenging tasks is not related to nondeterminism introduced by the framework. The Angular core team did great design decisions for making the static code analysis and tooling possible.</p>

<h2 id="resources">Resources</h2>

<ul>
<li><a href="https://github.com/mgechev/ng2lint">ng2lint&rsquo;s Official Repository</a></li>
<li><a href="https://palantir.github.io/tslint/">tslint&rsquo;s Official Page</a></li>
<li><a href="https://github.com/angular/angular">Angular 2&rsquo;s Official Repository</a></li>
<li><a href="https://github.com/Microsoft/TypeScript">TypeScript&rsquo;s Official Repository</a></li>
<li><a href="http://www.amazon.com/Modern-Compiler-Design-Dick-Grune/dp/1461446988">Modern Compiler Design 2nd ed. 2012 Edition</a></li>
<li><a href="http://www.amazon.com/gp/product/052182060X/">Modern Compiler Implementation in Java 2nd Edition</a></li>
<li><a href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite Automata</a></li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular Expressions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free grammars</a></li>
<li><a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">Extended Backus–Naur Form</a></li>
<li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax trees</a></li>
</ul>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mgechev';

     
    (function () {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    <div class="by-author">with <i class="fa fa-heart" aria-hidden="true"></i> by Minko Gechev</div>
    <p class="small">
         © Copyright 2019  
    </p>
</footer>
        </section>

        <script src="https://blog.mgechev.com/js/main.js"></script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-18060688-3', 'auto');
	
	ga('send', 'pageview');
}
</script>



<script async src="//twemoji.maxcdn.com/2/twemoji.min.js?2.3.0"></script>
<script>
  window.addEventListener('load', function () {
    twemoji.parse(document.body, { size: 72 });
  });
</script>



    </body>
</html>
