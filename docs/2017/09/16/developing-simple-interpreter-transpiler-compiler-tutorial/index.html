    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		<meta name="generator" content="Hugo 0.91.2" />
		<title>Implementing a Simple Compiler on 25 Lines of JavaScript &middot; Minko Gechev&#39;s blog</title>
		<link rel="shortcut icon" href="https://blog.mgechev.com/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/highlight.css">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/style.css">
		

		
		<link rel="stylesheet" href="https://blog.mgechev.com/css/font-awesome.min.css">
		

		
		<link href="https://blog.mgechev.com/feed.xml" rel="alternate" type="application/rss+xml" title="Minko Gechev&#39;s blog">
		
		
		<link rel="amphtml" href="https://blog.mgechev.com/amp/2017/09/16/developing-simple-interpreter-transpiler-compiler-tutorial/">
		

		<meta property="og:title" content="Implementing a Simple Compiler on 25 Lines of JavaScript" />
		<meta property="og:description" content="I already wrote a couple of essays related to the development of programming languages that I was extremely excited about! For instance, in &ldquo;Static Code Analysis of Angular 2 and TypeScript Projects&quot;[1] I explored the basics of the front end of the compilers, explaining the phases of lexical analysis, syntax analysis and abstract-syntax trees.
Recently I published &ldquo;Developing Statically Typed Programming Language&quot;[2]. This post shown a simple, statically typed, functional programming language inspired by lambda calculus." />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://blog.mgechev.com/2017/09/16/developing-simple-interpreter-transpiler-compiler-tutorial/" />
		
		<meta property="og:image" content="https://blog.mgechev.com/images/myself.jpg"/>
		<meta property="og:image:secure_url" content="https://blog.mgechev.com/images/myself.jpg"/>
		
	</head>

    <body>
       <nav class="main-nav">
  
  <div class="link-wrapper">
	
	
		<a href='https://blog.mgechev.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blog.mgechev.com/post'>Posts</a>
	<a href='https://blog.mgechev.com/about'>About</a>
	<a href='https://blog.mgechev.com/talks'>Speaking</a>
  </div>

	

	
  
	
</nav>
<a href="https://github.com/mgechev" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="z-index: 100000; fill:#70B7FD; color:#fff; position: fixed; top: 20px; border: 0; left: 20px; transform: scale(-1.5, 1.5);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Implementing a Simple Compiler on 25 Lines of JavaScript
                    </h1>
                    <h2 class="headline">
                    <a href="https://github.com/mgechev/blog.mgechev.com/tree/master/content/post/2017-09-16-developing-simple-interpreter-transpiler-compiler-tutorial.md">
                        <i class="fa fa-pencil-square-o"></i> Edit
                    </a>
                    · Sep 16, 2017
                    · 12 minutes read
                    · <a href="https://twitter.com/mgechev?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="true">Follow @mgechev</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                      <span class="tags">
                      
                      
                          
                              <a href="https://blog.mgechev.com/tags/compilers">Compilers</a>
                          
                              <a href="https://blog.mgechev.com/tags/lexical-analysis">Lexical Analysis</a>
                          
                              <a href="https://blog.mgechev.com/tags/syntax-analysis">Syntax Analysis</a>
                          
                              <a href="https://blog.mgechev.com/tags/computer-science">Computer Science</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p>I already wrote a couple of essays related to the development of programming languages that I was extremely excited about! For instance, in &ldquo;<a href="https://blog.mgechev.com/2016/02/29/static-code-analysis-angular-typescript/">Static Code Analysis of Angular 2 and TypeScript Projects</a>&quot;<sup>[1]</sup> I explored the basics of the front end of the compilers, explaining the phases of lexical analysis, syntax analysis and abstract-syntax trees.</p>
<p>Recently I published &ldquo;<a href="https://blog.mgechev.com/2017/08/05/typed-lambda-calculus-create-type-checker-transpiler-compiler-javascript/">Developing Statically Typed Programming Language</a>&quot;<sup>[2]</sup>. This post shown a simple, statically typed, functional programming language inspired by lambda calculus. There I outsourced the front end part of the compiler development to a parser generator and focused on the back end in the faces of a module for type checking and one for code generation.</p>
<h1 id="why-do-i-need-this">Why do I need this?</h1>
<p>You might be now wondering &ldquo;<em>Why would I need to know how to develop a compiler?</em>&rdquo;. There are a few important reasons:</p>
<ul>
<li>You will get a better understanding of how the programming languages you&rsquo;re using work. This will allow you to develop more efficient programs with them.</li>
<li>Often, you&rsquo;ll have to reuse pieces of the modules described below for different purposes (for instance, parsing of configuration files, parsing of network messages, etc.).</li>
<li>Creating a DSL. Creating a Domain Specific Language in your project could be quite handy in order to simplify tasks which otherwise take a lot of time to solve with a general purpose programming language.</li>
</ul>
<h1 id="what-are-we-going-to-cover">What are we going to cover?</h1>
<p>In this blog post we&rsquo;ll cover the basics from end-to-end! We&rsquo;ll develop an extremely simple compiler on 25 lines of JavaScript! Our compiler will have:</p>
<ul>
<li>Module for lexical analysis</li>
<li>Module for syntax analysis
<ul>
<li>The parser will be based on an EBNF grammar</li>
<li>We will develop the parser by using a recursive descent parsing algorithm</li>
</ul>
</li>
<li>Code generator</li>
</ul>
<p>The language that we&rsquo;re going to explore is not particularly useful for developing meaningful software programs but it can be easily extended to one.</p>
<p><a href="https://github.com/mgechev/tiny-compiler"><strong>The entire implementation can be found at my GitHub profile</strong></a><sup>[3]</sup>.</p>
<img src="/images/simple-compiler/simple.jpg" alt="Simplicity"  style="display: block; margin: auto;">
<h1 id="introducing-a-simple-prefix-language">Introducing a Simple Prefix Language</h1>
<p>Here&rsquo;s how a sample expression in our language is going to look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mul 3 sub 2 sum 1 3 4
</code></pre></div><p>By the end of this article we&rsquo;ll be able to transpile these expressions to JavaScript by going through phases typical for any compiler!</p>
<p>For simplicity, there are a few rules we need to follow:</p>
<ul>
<li>We have only the functions: <code>mul</code>, <code>sub</code>, <code>sum</code>, <code>div</code>.</li>
<li>Each individual string token is surrounded by whitespace.</li>
<li>We support only natural numbers.</li>
</ul>
<p>In order to explore the semantics behind the expression above let&rsquo;s define a few JavaScript functions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">mul</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">operands</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">operands</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">operands</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">operands</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">c</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">operands</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">operands</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><p><code>mul</code> accepts multiple operands, passed with the spread operator. The function just multiplies all of them, so for instance <code>mul(2, 3, 4) === 24</code>. <code>sub</code> respectively subtracts the passed arguments and <code>sum</code> sums them.</p>
<p>The expression above can be translated to the following JavaScript expression:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mul(3, sub(2, sum(1, 3, 4)))
</code></pre></div><p>or&hellip;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">3 * (2 - (1 + 3 + 4))
</code></pre></div><p>Now, after we have understanding of the semantics, let&rsquo;s start with the front end of the compiler!</p>
<p><em><strong>Note</strong>: Similar prefix expressions can be simply evaluated with a stack-based algorithm, however, in this case we&rsquo;ll focus on concepts rather than implementation.</em></p>
<h1 id="developing-the-compilers-front-end">Developing the Compiler&rsquo;s Front End</h1>
<p>The front end of any compiler usually has the modules for <a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">Lexical Analysis</a><sup>[4]</sup> and <a href="https://en.wikibooks.org/wiki/Compiler_Construction/Syntax_Analysis">Syntax Analysis</a><sup>[5]</sup>. In this section we&rsquo;ll build both modules in a few lines of JavaScript!</p>
<h2 id="developing-a-lexical-analyzer">Developing a Lexical Analyzer</h2>
<p>The phase of lexical analysis is responsible for dividing the input string (or stream of characters) of the program into smaller pieces called <strong>tokens</strong>. The tokens usually carry information about their type (if they are numbers, operators, keywords, identifiers, etc), the substring of the program they represent and their position in the program. The position is usually used for reporting user friendly errors in case of invalid syntactical constructs.</p>
<p>For instance, if we have the JavaScript program:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>A sample lexical analyzer for JavaScript will produce the output:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;if&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;keyword&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">row</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">col</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;open_paran&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">row</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">col</span><span class="o">:</span> <span class="mi">3</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">lexeme</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;identifier&#39;</span><span class="p">,</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">row</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">col</span><span class="o">:</span> <span class="mi">4</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">...</span>
<span class="p">]</span>
</code></pre></div><p>We&rsquo;ll keep our lexical analyzer as simple as possible. In fact, we&rsquo;ll implement it on a single line of JavaScript:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">lex</span> <span class="o">=</span> <span class="nx">str</span> <span class="p">=&gt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">trim</span><span class="p">()).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</code></pre></div><p>Here we split the string by a single space, we map the produced substrings to their trimmed version and filter the empty strings.</p>
<p>Invoking the lexer with an expression will produce an array of strings:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">lex</span><span class="p">(</span><span class="s1">&#39;mul 3 sub 2 sum 1 3 4&#39;</span><span class="p">)</span>

<span class="c1">// [&#34;mul&#34;, &#34;3&#34;, &#34;sub&#34;, &#34;2&#34;, &#34;sum&#34;, &#34;1&#34;, &#34;3&#34;, &#34;4&#34;]
</span></code></pre></div><p>This is completely enough for our purpose!</p>
<p>Now let&rsquo;s go to the phase of syntax analysis!</p>
<h1 id="developing-a-parser">Developing a Parser</h1>
<p>The syntax analyzer (often known as parser) is the module of a compiler which out of a list (or stream) of tokens produces an <a href="https://en.wikibooks.org/wiki/Compiler_Construction/Case_Study_1B#Abstract_Syntax_Trees">Abstract Syntax Tree</a><sup>[6]</sup> (or in short an AST). Along the process, the syntax analyzer may also produce syntax errors in case of invalid programs.</p>
<img src="/images/simple-compiler/tree.jpg" alt="Nature Tree" style="display: block; margin: auto;">
<p>Usually, the parser is implemented based on a <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">grammar</a><sup>[7]</sup>. Here&rsquo;s the grammar of our language:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
num = digit+
op = sum | sub | mul | div
expr = num | op expr+
</code></pre></div><p>This basically means that we have digits which composed together can form numbers (<code>num</code>). We have 4 operations and an expression which can be either a <code>num</code>ber, or <code>op</code>eration, followed by one or more <code>expr</code>essions. We&rsquo;ll refer to the individual definitions in the grammar (for instance to <code>num</code> and <code>op</code>) as rules.</p>
<p>This is the so called <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF grammar</a><sup>[6]</sup>. Look at the grammar for a bit, try to understand it, and after that completely forget about it! We&rsquo;ll come back to the grammar after we explain the parser and you&rsquo;ll see how everything connects together!</p>
<p>As we mentioned, a parser is a tool which turns a list of tokens to an AST.</p>
<p>For instance, for our expression:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mul 3 sub 2 sum 1 3 4
</code></pre></div><p>The parser will produce the following AST, based on the grammar above:</p>
<div style="width: 300px; height: 300px; display: block; margin: auto;">
  <img src="/images/simple-compiler/ast.svg">
</div>
<p>Let&rsquo;s explore the algorithm for this!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Op</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;op&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">Num</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">parse</span> <span class="o">=</span> <span class="nx">tokens</span> <span class="p">=&gt;</span> <span class="p">{</span>

  <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kr">const</span> <span class="nx">peek</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">tokens</span><span class="p">[</span><span class="nx">c</span><span class="p">];</span>
  <span class="kr">const</span> <span class="nx">consume</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">tokens</span><span class="p">[</span><span class="nx">c</span><span class="o">++</span><span class="p">];</span>

  <span class="kr">const</span> <span class="nx">parseNum</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">val</span><span class="o">:</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">consume</span><span class="p">()),</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span> <span class="p">});</span>

  <span class="kr">const</span> <span class="nx">parseOp</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">val</span><span class="o">:</span> <span class="nx">consume</span><span class="p">(),</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">Op</span><span class="p">,</span> <span class="nx">expr</span><span class="o">:</span> <span class="p">[]</span> <span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">peek</span><span class="p">())</span> <span class="nx">node</span><span class="p">.</span><span class="nx">expr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">parseExpr</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kr">const</span> <span class="nx">parseExpr</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="o">/</span><span class="err">\</span><span class="nx">d</span><span class="o">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">peek</span><span class="p">())</span> <span class="o">?</span> <span class="nx">parseNum</span><span class="p">()</span> <span class="o">:</span> <span class="nx">parseOp</span><span class="p">();</span>

  <span class="k">return</span> <span class="nx">parseExpr</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><p>The bad news is that there are a lot of things going on. The good news is that this is the most complicated part of the compiler!</p>
<p>Let&rsquo;s divide the code into parts and look into each one step by step.</p>
<h2 id="node-types">Node Types</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Op</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;op&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">Num</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">);</span>
</code></pre></div><p>First we define the different node types that we are going to have in the AST. We&rsquo;ll have only numbers and operations. For example, the number node <code>42</code> will look like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span><span class="p">,</span>
  <span class="nx">val</span><span class="o">:</span> <span class="mi">42</span>
<span class="p">}</span>
</code></pre></div><p>The operator <code>sum</code>, applied to <code>2</code>, <code>3</code>, <code>4</code> will look like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="nx">type</span><span class="o">:</span> <span class="nx">Op</span><span class="p">,</span>
  <span class="nx">val</span><span class="o">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
  <span class="nx">expr</span><span class="o">:</span> <span class="p">[{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span><span class="p">,</span>
    <span class="nx">val</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span><span class="p">,</span>
    <span class="nx">val</span><span class="o">:</span> <span class="mi">3</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span><span class="p">,</span>
    <span class="nx">val</span><span class="o">:</span> <span class="mi">4</span>
  <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div><p>That&rsquo;s how simple is that!</p>
<h2 id="the-parser">The Parser</h2>
<p>After we declare the node types, we define a function called <code>parse</code> which accepts a single argument called <code>tokens</code>. Inside of it we define five more functions:</p>
<ul>
<li><code>peek</code> - returns the element of <code>tokens</code> associated with the current value of the <code>c</code> local variable.</li>
<li><code>consume</code> - returns the element of <code>tokens</code> associated with the current value of the <code>c</code> local variable and increments <code>c</code>.</li>
<li><code>parseNum</code> - gets the current token (i.e. invokes <code>peek()</code>), parses it to a natural number and returns a new number token.</li>
<li><code>parseOp</code> - we&rsquo;ll explore in a little bit.</li>
<li><code>parseExpr</code> - checks if the current token matches the regular expression <code>/\d/</code> (i.e. is a number) and invokes <code>parseNum</code> if the match was successful, otherwise returns <code>parseOp</code>.</li>
</ul>
<h3 id="parsing-operations">Parsing Operations</h3>
<p>The <code>parseOp</code> is maybe the most complicated function from the parser above. That&rsquo;s the case because of the loop and the indirect recursion that we have. Here&rsquo;s its definition one more time in order to explain it line by line:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">parseOp</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">val</span><span class="o">:</span> <span class="nx">consume</span><span class="p">(),</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">Op</span><span class="p">,</span> <span class="nx">expr</span><span class="o">:</span> <span class="p">[]</span> <span class="p">};</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">peek</span><span class="p">())</span> <span class="nx">node</span><span class="p">.</span><span class="nx">expr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">parseExpr</span><span class="p">());</span>
  <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>Since <code>parseOp</code> has been invoked by <code>parseExpr</code> when the value of <code>peek()</code> is not a number we know that it is an operator so we create a new operation node. Note that we don&rsquo;t perform any further validation, however, in a real-world programming language we&rsquo;d want to do that and eventually throw a syntax error in case of unexpected token.</p>
<p>Anyhow, in the node declaration we set the list of &ldquo;sub-expressions&rdquo; to be the empty list (i.e. <code>[]</code>), the operation name to the value of <code>consume()</code> and the type of the node to <code>Op</code>. Later, while we don&rsquo;t reach the end of the program, we loop over all tokens by pushing the currently parsed expression to the list of &ldquo;sub-expressions` of the given node. Finally, we return the node.</p>
<p>Keep in mind that <code>while (peek()) node.expr.push(parseExpr());</code> performs an indirect recursion. In case we have the expression:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">sum sum 2
</code></pre></div><p>This will</p>
<ul>
<li>First, invoke <code>parseExpr</code>, which will find that the current token (i.e. <code>tokens[0]</code>) is not a number (it&rsquo;s <code>sum</code>) so it&rsquo;ll invoke <code>parseOp</code>.</li>
<li>After that <code>parseOp</code> will create the operation node and because of the <code>consume()</code> call, increment the value of <code>c</code>.</li>
<li>Next <code>parseOp</code> will iterate over the tokens, and for <code>tokens[c]</code>, where <code>c</code> now equals <code>1</code> will invoke <code>parseExpr</code>.</li>
<li><code>parseExpr</code> will find that the current token is not a number so it&rsquo;ll invoke <code>parseOp</code>.</li>
<li><code>parseOp</code> will create another operation node and increment <code>c</code> and will start looping over the remaining tokens again.</li>
<li><code>parseOp</code> will invoke <code>parseExpr</code> where <code>c</code> will now equal <code>2</code>.</li>
<li>Since <code>tokens[2] === &quot;2&quot;</code>, <code>parseExpr</code> will invoke <code>parseNum</code> which will create a number node, incrementing the <code>c</code> variable.</li>
<li><code>parseNum</code> will return the number node and it will be pushed into the <code>expr</code> array of the last operation node produced by the latest <code>parseOp</code> invocation.</li>
<li>The last <code>parseOp</code> invocation will return the operation node since <code>peek()</code> will return <code>undefined</code> (<code>parseNum</code> has incremented <code>c</code> to <code>3</code> and <code>tokens[3] === undefined</code>).</li>
<li>The node returned by the last invocation of <code>parseOp</code> will be returned to the outermost invocation of <code>parseOp</code> which will return its operation node as well.</li>
<li>Finally, <code>parseExpr</code> will return the root operation node.</li>
</ul>
<p>The produced AST will look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="nx">type</span><span class="o">:</span> <span class="nx">Op</span><span class="p">,</span>
  <span class="nx">val</span><span class="o">:</span> <span class="s2">&#34;sum&#34;</span><span class="p">,</span>
  <span class="nx">expr</span><span class="o">:</span> <span class="p">[{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">Op</span><span class="p">,</span>
    <span class="nx">val</span><span class="o">:</span> <span class="s2">&#34;sum&#34;</span><span class="p">,</span>
    <span class="nx">expr</span><span class="o">:</span> <span class="p">[{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nx">Num</span><span class="p">,</span>
      <span class="nx">val</span><span class="o">:</span> <span class="mi">2</span>
    <span class="p">}]</span>
  <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div><p>&hellip;and that&rsquo;s it! The final step is to traverse this tree and produce JavaScript!</p>
<h2 id="recursive-descent-parsing">Recursive Descent Parsing</h2>
<p>Now let&rsquo;s see how are the individual functions related to the grammar we defined above and see why having a grammar makes sense in general. Let&rsquo;s take a look at the rules in the EBNF grammar:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
num = digit+
op = sum | sub | mul | div
expr = num | op expr+
</code></pre></div><p>Do they now may make a bit more sense? <code>expr</code> looks very much like <code>parseExpr</code>, where we parse either a <code>num</code>ber or an <code>op</code>eration. Similarly, <code>op expr+</code> looks very much like <code>parseOp</code> and <code>num</code> like <code>parseNum</code>. In fact, very often parsers are generated directly from the grammars since there&rsquo;s a direct connection between both with the <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parsing algorithm</a><sup>[8]</sup>.</p>
<p>And in fact, we just developed a simple recursive descent parser! Our parser was quite simple (well, we have only 4 <strong>production rules</strong> in the grammar) but you can imagine how complex the parser of a real-life programming language is.</p>
<p>It&rsquo;s extremely convenient to develop the grammar of a language before writing the actual parser in order to observe a simplified model of it. The parser contains a lot of details (for instance a lot of syntax constructs of the language you&rsquo;re developing it with), in contrast to the grammar which is extremely simplified and minimalistic.</p>
<h1 id="developing-the-transpiler">Developing the Transpiler</h1>
<p>In this part of the post we&rsquo;ll traverse the AST of the language and produce JavaScript. The entire transpiler is on 7 lines of JavaScript (literally!):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">transpile</span> <span class="o">=</span> <span class="nx">ast</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">opMap</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">sum</span><span class="o">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="nx">mul</span><span class="o">:</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="nx">sub</span><span class="o">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="nx">div</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span> <span class="p">};</span>
  <span class="kr">const</span> <span class="nx">transpileNode</span> <span class="o">=</span> <span class="nx">ast</span> <span class="p">=&gt;</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">Num</span> <span class="o">?</span> <span class="nx">transpileNum</span><span class="p">(</span><span class="nx">ast</span><span class="p">)</span> <span class="o">:</span> <span class="nx">transpileOp</span><span class="p">(</span><span class="nx">ast</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">transpileNum</span> <span class="o">=</span> <span class="nx">ast</span> <span class="p">=&gt;</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">transpileOp</span> <span class="o">=</span> <span class="nx">ast</span> <span class="p">=&gt;</span> <span class="sb">`(</span><span class="si">${</span><span class="nx">ast</span><span class="p">.</span><span class="nx">expr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">transpileNode</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">opMap</span><span class="p">[</span><span class="nx">ast</span><span class="p">.</span><span class="nx">val</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="si">}</span><span class="sb">)`</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">transpileNode</span><span class="p">(</span><span class="nx">ast</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><p>Let&rsquo;s explore the implementation line by line.</p>
<p>First we define a function called <code>transpile</code>. It accepts as argument the AST produced by the parser. After that in the <code>opMap</code> we define the mapping between arithmetic operations and the operators in the language. Basically, <code>sum</code> maps to <code>+</code>, <code>mul</code> to <code>*</code>, etc.</p>
<p>As next step, we define the function <code>transpileNode</code> which accepts an AST node. If the node is a number, we invoke the <code>transpileNum</code> function with the given node, otherwise, we invoke <code>transpileOp</code>.</p>
<p>Finally, we define the two functions for transpilation of the individual nodes:</p>
<ul>
<li><code>transpileNum</code> - translates a number to a JavaScript number (simply by returning it).</li>
<li><code>transpileOp</code> - translates an operation to a JavaScript arithmetic operation. Notice that we have indirect recursion here (<code>transpileOp -&gt; transpileNode -&gt; transpileOp</code>). For each operation node, we want to transpile its sub-expressions first. We do that by invoking the <code>transpileNode</code> function.</li>
</ul>
<p>On the last line of <code>transpile</code>&rsquo;s body, we return the result of <code>transpileNode</code> applied to the root of the tree.</p>
<h1 id="wiring-everything-together">Wiring Everything Together</h1>
<p>Here&rsquo;s how we can wire everything together:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">program</span> <span class="o">=</span> <span class="s1">&#39;mul 3 sub 2 sum 1 3 4&#39;</span><span class="p">;</span>

<span class="nx">transpile</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="nx">lex</span><span class="p">(</span><span class="nx">program</span><span class="p">)));</span>
<span class="c1">// (3 * (2 - (1 + 3 + 4)))
</span></code></pre></div><p>We invoke <code>lex(program)</code>, which produces the list of tokens, after that we pass the tokens to the <code>parse</code> function, which produces the AST and finally, we <code>transpile</code> the AST to JavaScript!</p>
<img src="/images/simple-compiler/wire.jpg" alt="Connecting"  style="display: block; margin: auto;">
<h1 id="conclusion">Conclusion</h1>
<p>This article explained in details the development of a very simple compiler (or transpiler) of a language with prefix expressions to JavaScript. Although this was explanation of only the very basics of the compiler development we were able to cover few very important concepts:</p>
<ul>
<li>Lexical analysis</li>
<li>Syntax analysis</li>
<li>Source code generation</li>
<li>EBNF grammars</li>
<li>Recursive Descent Parsing</li>
</ul>
<p>If you&rsquo;re interested in further reading, I&rsquo;d recommend:</p>
<ul>
<li><a href="https://blog.mgechev.com/2017/08/05/typed-lambda-calculus-create-type-checker-transpiler-compiler-javascript/">Developing Statically Typed Programming Language</a></li>
<li><a href="https://ruslanspivak.com/lsbasi-part1/">Let’s Build A Simple Interpreter</a></li>
<li><a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">Compilers: Principles, Techniques, and Tools (2nd Edition) 2nd Edition</a></li>
<li><a href="https://www.amazon.com/Types-Programming-Languages-MIT-Press/dp/0262162091">Types and Programming Languages</a></li>
</ul>
<h1 id="references">References</h1>
<ol>
<li><a href="https://mgv.io/ng-static-analysis">Static Code Analysis of Angular 2 and TypeScript Projects - https://mgv.io/ng-static-analysis</a>.</li>
<li><a href="https://mgv.io/typed-lambda">Developing Statically Typed Programming Language - https://mgv.io/typed-lambda</a></li>
<li><a href="https://mgv.io/tiny-compiler">Tiny Compiler - https://mgv.io/tiny-compiler</a></li>
<li><a href="https://mgv.io/wiki-lex">Lexical Analysis - https://mgv.io/wiki-lex</a></li>
<li><a href="https://mgv.io/wiki-parser">Syntax Analysis - https://mgv.io/wiki-parser</a></li>
<li><a href="https://mgv.io/wiki-case-ast">Abstract Syntax Tree - https://mgv.io/wiki-case-ast</a></li>
<li><a href="https://mgv.io/wiki-ebnf">EBNF grammar - https://mgv.io/wiki-ebnf</a></li>
<li><a href="https://mgv.io/wiki-recursive-descent-parser">Recursive Descent Parsing - https://mgv.io/wiki-recursive-descent-parser</a></li>
</ol>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mgechev';

     
    (function () {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    <div class="by-author">with <i class="fa fa-heart" aria-hidden="true"></i> by Minko Gechev</div>
    <p class="small">
         © Copyright 2025  
    </p>
</footer>
        </section>

        <script src="https://blog.mgechev.com/js/main.js"></script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-18060688-3', 'auto');
	
	ga('send', 'pageview');
}
</script>


<script async src="//twemoji.maxcdn.com/2/twemoji.min.js?2.3.0"></script>
<script>
  window.addEventListener('load', function () {
    twemoji.parse(document.body, { size: 72 });
  });
</script>



    </body>
</html>
