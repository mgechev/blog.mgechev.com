    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		<meta name="generator" content="Hugo 0.55.5" />
		<title>Faster Angular Applications - Part 1. On Push Change Detection and Immutability &middot; Minko Gechev&#39;s blog</title>
		<link rel="shortcut icon" href="https://blog.mgechev.com/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/highlight.css">
		<link rel="stylesheet" href="https://blog.mgechev.com/css/style.css">
		

		
		<link rel="stylesheet" href="https://blog.mgechev.com/css/font-awesome.min.css">
		

		
		<link href="https://blog.mgechev.com/feed.xml" rel="alternate" type="application/rss+xml" title="Minko Gechev&#39;s blog">
		
		
		<link rel="amphtml" href="https://blog.mgechev.com/amp/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/">
		

		<meta property="og:title" content="Faster Angular Applications - Part 1. On Push Change Detection and Immutability" />
		<meta property="og:description" content="On AngularConnect 2017 in London, I gave a talk called &ldquo;Purely Fast.&rdquo; In the presentation, I showed how step by step we can improve the performance of a business application. In the example, I incorporated as many performance issues as possible which I faced over the past a couple of years developing enterprise Angular and AngularJS applications. After the presentation, I got great feedback for the content, so I decided to write a series of blog posts which aim to explain the content from &ldquo;Purely Fast&rdquo; in details." />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/" />
		
		<meta property="og:image" content="https://blog.mgechev.com/images/myself.jpg"/>
		<meta property="og:image:secure_url" content="https://blog.mgechev.com/images/myself.jpg"/>
		
	</head>

    <body>
       <nav class="main-nav">
  
  <div class="link-wrapper">
	
	
		<a href='https://blog.mgechev.com/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blog.mgechev.com/post'>Posts</a>
	<a href='https://blog.mgechev.com/about'>About</a>
	<a href='https://blog.mgechev.com/talks'>Speaking</a>
  </div>

	

	
  
	
</nav>
<a href="https://github.com/mgechev" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="z-index: 100000; fill:#70B7FD; color:#fff; position: fixed; top: 20px; border: 0; left: 20px; transform: scale(-1.5, 1.5);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Faster Angular Applications - Part 1. On Push Change Detection and Immutability
                    </h1>
                    <h2 class="headline">
                    <a href="https://github.com/mgechev/blog.mgechev.com/tree/master/content/post/2017-11-11-faster-angular-applications-onpush-change-detection-immutable-part-1.md">
                        <i class="fa fa-pencil-square-o"></i> Edit
                    </a>
                    · Nov 11, 2017
                    · 14 minutes read
                    · <a href="https://twitter.com/mgechev?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="true">Follow @mgechev</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                      <span class="tags">
                      
                      
                          
                              <a href="https://blog.mgechev.com/tags/angular">Angular</a>
                          
                              <a href="https://blog.mgechev.com/tags/performance">Performance</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>On AngularConnect 2017 in London, I gave a talk called &ldquo;Purely Fast.&rdquo; In the presentation, I showed how step by step we can improve the performance of a business application. In the example, I incorporated as many performance issues as possible which I faced over the past a couple of years developing enterprise Angular and AngularJS applications. After the presentation, I got great feedback for the content, so I decided to write a series of blog posts which aim to explain the content from &ldquo;Purely Fast&rdquo; in details.</p>

<p>In this part, we will focus on immutable data structures and <code>OnPush</code> change detection.</p>

<p>The code for this blog post is available at my <a href="https://github.com/mgechev">GitHub account</a>:</p>

<ul>
<li><a href="https://github.com/mgechev/purely-fast">&ldquo;Purely Fast&rdquo;</a></li>
<li><a href="https://github.com/mgechev/purely-fast-benchmarks">&ldquo;Purely Fast - Benchmarks&rdquo;</a></li>
<li><a href="/2017/11/12/faster-angular-applications-pure-pipes-memoization-pure-functions-part-2/">&ldquo;Faster Angular Applications - Part 2&rdquo;</a></li>
</ul>

<h1 id="why-runtime-performance">Why runtime performance</h1>

<p>A big issue in the modern single-page applications is reducing the initial load time. This includes reducing the number of bytes transferred over the network and minimizing the number of network requests. Last year I wrote a few articles related to reducing the bundle size (you can find them <a href="https://blog.mgechev.com/2016/06/26/tree-shaking-angular2-production-build-rollup-javascript/">here</a> and <a href="https://blog.mgechev.com/2016/07/21/even-smaller-angular2-applications-closure-tree-shaking/">here</a>). Although it&rsquo;s always a good idea to invest time in exploring the bundles of our apps in details with tools like <a href="https://www.npmjs.com/package/source-map-explorer">source-map-explorer</a> and reducing its size, there are many folks working in this direction.</p>

<p>For instance, the Google Closure Compiler team is continuously trying to provide the most optimal minification and dead code elimination, same for the webpack team. On top of that, we have the Angular CLI team which combines the best from both worlds by allowing us to have the most efficient and well-encapsulated build possible.</p>

<p>In the end, all we can do is either combine effort with any of these teams to improve the minification that their tools provide or apply some application-specific optimizations such as lazy-loading.</p>

<p>On the other hand, the runtime performance of our applications is entirely in our own hands. Before going any further, lets put the practices that we&rsquo;re going to look at into the context of a simplified business application.</p>

<h1 id="introducing-a-sample-business-application">Introducing a Sample Business Application</h1>

<p>We&rsquo;re going to put all the practices for performance improvement into the context of this sample business application.</p>

<p><img src="/images/faster-ng-apps-1/app.gif" style="border: 1px solid #ccc;"></p>

<p>On the GIF above you can see the business application that we&rsquo;re going to optimize. On the screen we have:</p>

<ul>
<li>Two lists of the employees in two different departments - Sales and R&amp;D.</li>
<li>Each employee has a name and a numeric value associated with them. The numeric value is represented in a material design chip component and goes through some business computation (for instance, standard deviation or any other meaningful calculation). The value we see in the material design chip component is the resulted number.</li>
<li>Right next to each employee we have a button for deleting it.</li>
<li>Each of the department lists has a text input where we can enter the name of a new employee. When we add a new item, we get the employees numeric value somehow (in our case we&rsquo;ll generate it), process it with our business calculation and visualize it on the screen.</li>
</ul>

<p>That&rsquo;s pretty much all we have! Let&rsquo;s take a brief look at the component structure of the application.</p>

<p><img src="/images/faster-ng-apps-1/structure.png"></p>

<p>The image above shows the component structure of the application. We have a component called <code>AppComponent</code> which wraps the entire application, and two instances of the <code>EmployeeListComponent</code> which show the employees from the individual departments.</p>

<p>Now lets take a look at the template of the <code>EmployeeListComponent</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">h1</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Department&#34;</span><span class="p">&gt;</span>{{ department }}<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">mat-form-field</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">placeholder</span><span class="o">=</span><span class="s">&#34;Enter name here&#34;</span> <span class="na">matInput</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="err">[(</span><span class="na">ngModel</span><span class="err">)]=&#34;</span><span class="na">label</span><span class="err">&#34;</span> <span class="err">(</span><span class="na">keydown</span><span class="err">)=&#34;</span><span class="na">handleKey</span><span class="err">($</span><span class="na">event</span><span class="err">)&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">mat-form-field</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">mat-list</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">mat-list-item</span> <span class="err">*</span><span class="na">ngFor</span><span class="o">=</span><span class="s">&#34;let item of data&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h3</span> <span class="na">matLine</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Name&#34;</span><span class="p">&gt;</span>
      {{ item.label }}
    <span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">mat-chip-list</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">md-chip</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Score&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;mat-chip mat-primary mat-chip-selected&#34;</span> <span class="na">color</span><span class="o">=</span><span class="s">&#34;primary&#34;</span> <span class="na">selected</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;</span>
        {{ calculate(item.num) }}
      <span class="p">&lt;/</span><span class="nt">md-chip</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">mat-chip-list</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">i</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Delete&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fa fa-trash-o&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span> <span class="err">(</span><span class="na">click</span><span class="err">)=&#34;</span><span class="na">remove</span><span class="err">.</span><span class="na">emit</span><span class="err">(</span><span class="na">item</span><span class="err">)&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">mat-list-item</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">mat-list</span><span class="p">&gt;</span></code></pre></div>
<p>Firstly, we print the department name. After that, we declare a material design form field where with <code>ngModel</code> we create two-way data-binding between the <code>label</code> property declared inside of the <code>EmployeeListComponent</code>&rsquo;s controller and the text input.</p>

<p>Right after that, we declare a list of items, and we iterate over the individual employees, show their name and calculate the numeric value associated with them. We directly invoke the <code>calculate</code> method inside the template. The <code>calculate</code> method is defined inside the controller of <code>EmployeeListComponent</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">const</span> <span class="nx">fibonacci</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">num</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">num</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">@Component</span><span class="p">(...)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">EmployeeListComponent</span> <span class="p">{</span>
  <span class="kd">@Input</span><span class="p">()</span> <span class="nx">data</span>: <span class="kt">EmployeeData</span><span class="p">[];</span>
  <span class="kd">@Input</span><span class="p">()</span> <span class="nx">department</span>: <span class="kt">string</span><span class="p">;</span>

  <span class="kd">@Output</span><span class="p">()</span> <span class="nx">remove</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="o">&lt;</span><span class="nx">EmployeeData</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="kd">@Output</span><span class="p">()</span> <span class="nx">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="nx">label</span>: <span class="kt">string</span><span class="p">;</span>

  <span class="nx">handleKey</span><span class="p">(</span><span class="nx">event</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">===</span> <span class="mi">13</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">add</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">label</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">calculate</span><span class="p">(</span><span class="nx">num</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The definition of the <code>EmployeeListComponent</code> is quite simple:</p>

<ul>
<li>It has two inputs:

<ul>
<li><code>data</code> - a list of the employees from the specific department.</li>
<li><code>department</code> - the name of the department.</li>
</ul></li>
<li>&hellip;and two outputs:

<ul>
<li><code>remove</code> - triggered when we remove an employee from the list.</li>
<li><code>add</code> - triggered when we add a new employee to the list.</li>
</ul></li>
</ul>

<p>The inputs are going to be passed from the <code>AppComponent</code> to its child <code>EmployeeListComponent</code> instances.</p>

<h2 id="business-calculation">Business Calculation</h2>

<p>Notice that we&rsquo;re mocking the business calculation with a function which calculates the number of Fibonacci from the employee&rsquo;s numeric value. This way instead of introducing a complicated business calculation we can focus entirely on the performance optimizations that we&rsquo;re going to perform. The Fibonacci function defined above has the same properties as any other mathematical function which we may use for calculating some meaningful value for the employee.</p>

<p>You might have also noticed that we&rsquo;re calculating the <code>n</code><sup>th</sup> number of Fibonacci by performing an extremely inefficient calculation:</p>

<p><img src="/images/faster-ng-apps-1/fibonacci.png" style="border: 1px solid #ccc;"></p>

<p>We do that to slow down our application artificially and simulate as precisely as possible a computationally intensive business calculation.</p>

<h2 id="application-structure-recap">Application Structure Recap</h2>

<ul>
<li>We have an application root component with two children components.</li>
<li>Each children component is an instance of the <code>EmployeeListComponent</code> which has some list items.</li>
<li>For each list item, we have a computationally intensive calculation.</li>
</ul>

<h1 id="typing-speed">Typing Speed</h1>

<p>On the image below you can see what the typing experience is when both lists have in total of 140 items. No, unfortunately, it does not look slow because of the frame rate of the GIF.</p>

<p><img src="/images/faster-ng-apps-1/slow-typing.gif" style="border: 1px solid #ccc;"></p>

<p>There&rsquo;s obviously something going on. In order to debug it, we can turn to <code>Chrome DevTools &gt; Performance</code>:</p>

<p><img src="/images/faster-ng-apps-1/script-time.png" style="border: 1px solid #ccc;"></p>

<p>As we can see from this screenshot, as expected, most of the slowdowns happen because of a heavy computations happening in the main thread. If we switch to the <code>Bottom-Up</code> tab we can see the following:</p>

<p><img src="/images/faster-ng-apps-1/fibonacci-slow.png" style="border: 1px solid #ccc;"></p>

<p>We can see that the <code>fibonacci</code> function takes most of the script time. Lets see how often it gets invoked by adding a log statement inside of the <code>calculate</code> method defined in <code>EmployeeListComponent</code>:</p>

<p><img src="/images/faster-ng-apps-1/why-slow.gif" style="border: 1px solid #ccc;"></p>

<p>The image above shows that the <code>fibonacci</code> function gets invoked multiple times for each entry in both lists. In fact, it gets invoked at least twice for each item in the list when we type a single character:</p>

<ul>
<li>Once after the callbacks associated with the <code>mousedown</code> event of the input.</li>
<li>Once after the callbacks associated with the <code>mouseup</code> event of the input.</li>
</ul>

<p>Although we have calculated the numeric values for all the employees in the list and we have visualized them we&rsquo;re recomputing them again, multiple times. This happens because the Angular&rsquo;s change detection gets triggered after each of the listed events above. Once the change detection gets triggered, it&rsquo;ll re-evaluate all the expressions in the templates and compare them with their previous values. If there&rsquo;s a change, the Angular&rsquo;s change detection will update the DOM most efficiently. This means that <strong>each change detection tick will re-evaluate all the expressions in the templates of the components.</strong> Based on this, very important advice that I included in the <a href="https://github.com/mgechev/angular-performance-checklist">&ldquo;Angular Performance Checklist&rdquo;</a> is - <strong>do not perform heavy computations in templates</strong>.</p>

<p>Well, in our case we&rsquo;re 100% sure that the numeric values for the two lists of employees haven&rsquo;t changed, which means that Angular will not find any reason to update the DOM. The question is - how to tell Angular to not recompute the numeric values for the employees unless it gets new lists for the two departments?</p>

<h1 id="on-push-change-detection-strategy">On Push Change Detection Strategy</h1>

<p>The answer to this question is to use a custom change detection strategy. In fact, the <code>OnPush</code> change detection strategy is exactly what we&rsquo;re looking for. By <strong>setting the change detection</strong> of <code>EmployeeListComponent</code> <strong>to <code>OnPush</code></strong> we <strong>will hint Angular that it should not run its change detection mechanism for this component unless it receives a new value for any of its inputs</strong>. Keep in mind that Angular will use equality check in order to verify that!</p>

<h2 id="components-as-functions">Components as Functions</h2>

<p>In order to explain this, let&rsquo;s suppose for a second that <code>EmployeeListComponent</code> is a function. Let&rsquo;s also suppose that the function&rsquo;s arguments are the inputs of the <code>EmployeeListComponent</code> and the result that the function returns is the DOM rendered on the screen. So:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">function</span> <span class="nx">runChangeDetection() {</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Detecting for changes&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">EmployeeListComponent</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">shouldRun</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">||</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">EmployeeListComponent</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">EmployeeListComponent</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="p">});</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">shouldRun</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">runChangeDetection</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">EmployeeListComponent</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="nx">e1</span><span class="p">];</span></code></pre></div>
<p>In the snippet above <strong>we&rsquo;ve modeled</strong> the <code>EmployeeListComponent</code> as a function. We have three important things going on there:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">const</span> <span class="nx">shouldRun</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">||</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">EmployeeListComponent</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span></code></pre></div>
<p>Will return <code>true</code> if any of the values of the object literal <code>args</code> we passed differs from the values associated with the same keys in the <code>EmployeeListComponent</code>. This check is algorithmically similar to the check that Angular is going to perform to decide if the change detection for a component with <code>OnPush</code> change detection strategy should be invoked.</p>

<p>After that we have:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">EmployeeListComponent</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">});</span></code></pre></div>
<p>This simply sets the &ldquo;inputs.&rdquo; Finally, we have:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="k">if</span> <span class="p">(</span><span class="nx">shouldRun</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">runChangeDetection</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>Which runs the change detection.</p>

<p>Now, <code>f</code> is our <code>EmployeeListComponent</code> and <code>data</code> is the list of employees which initially contains only a single item - <code>e1</code>. If we invoke <code>f</code> and pass <code>data</code> as an argument (in the language of Angular, as an input):</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// will invoke `runChangeDetection`.
</span><span class="c1"></span><span class="nx">f</span><span class="p">({</span> <span class="nx">data</span>: <span class="kt">data</span> <span class="p">});</span></code></pre></div>
<p>&hellip;the change detection will be triggered since the initial value of the input <code>data</code> was <code>undefined</code>. This will be the behavior in Angular as well if we pass an input with a different value. However, if run:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">e2</span><span class="p">);</span>
<span class="nx">f</span><span class="p">({</span> <span class="nx">data</span>: <span class="kt">data</span> <span class="p">});</span></code></pre></div>
<p>Although we pass <code>data</code> as an argument (or input) again, the change detection will not be invoked because after performing an equality check we will determine that the previous value of the input <code>data</code> has the same reference. On the other hand, if we:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="nx">f</span><span class="p">({</span> <span class="nx">data</span>: <span class="kt">data.slice</span><span class="p">()</span> <span class="p">});</span></code></pre></div>
<p>We will trigger its change detection because we&rsquo;d have passed a new reference for the <code>data</code> input. That&rsquo;s pretty much how the things will happen in Angular as well.</p>

<p>This means that we can update <code>EmployeeListComponent</code> to the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">changeDetection</span>: <span class="kt">ChangeDetectionStrategy.OnPush</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">EmployeeListComponent</span> <span class="p">{</span>
  <span class="kd">@Input</span><span class="p">()</span> <span class="nx">data</span>: <span class="kt">EmployeeData</span><span class="p">[];</span>
  <span class="kd">@Input</span><span class="p">()</span> <span class="nx">department</span>: <span class="kt">string</span><span class="p">;</span>

  <span class="nx">handleKey</span><span class="p">(</span><span class="nx">event</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">===</span> <span class="mi">13</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">add</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">label</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span></code></pre></div>
<p>&hellip;and <code>AppComponent</code> to:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Component</span><span class="p">({</span>
  <span class="nx">template</span><span class="o">:</span> <span class="sb">`
</span><span class="sb">    &lt;sd-employee-list [data]=&#34;salesList&#34; department=&#34;Sales&#34; (add)=&#34;addToSales($event)&#34;&gt;
</span><span class="sb">  `</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AppComponent</span> <span class="kr">implements</span> <span class="nx">OnInit</span> <span class="p">{</span>
  <span class="nx">salesList</span>: <span class="kt">EmployeeData</span><span class="p">[];</span>

  <span class="nx">addToSales</span><span class="p">(</span><span class="nx">name</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">salesList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">salesList</span>
      <span class="p">.</span><span class="nx">unshift</span><span class="p">({</span> <span class="nx">label</span>: <span class="kt">name</span><span class="p">,</span> <span class="nx">num</span>: <span class="kt">this.generator.generateNumber</span><span class="p">(</span><span class="nx">NumRange</span><span class="p">)</span> <span class="p">})</span>
      <span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span></code></pre></div>
<p>This way, each time when the user presses &ldquo;Enter&rdquo; we will emit the value of the <code>label</code> using the <code>add</code> output. <code>AppComponent</code> will handle the output with its <code>addToSales</code> method which will push a new employee to the <code>salesList</code>, copy the entire list and set the returned new reference as the value of the <code>salesList</code>.</p>

<p>All right, this will work; however, we introduce two issues:</p>

<ul>
<li>It&rsquo;ll be slow. Every time we add an employee we need to copy the entire list. The garbage collector should also run to clean the unused memory.</li>
<li>It&rsquo;ll require a lot of memory. Well, the memory we allocated for the new list could be a lot depending on the size of the list.</li>
</ul>

<p>To handle these two issues we can use efficiently implemented immutable data structures such as Immutable.js.</p>

<h2 id="introducing-immutable-js">Introducing Immutable.js</h2>

<p>I&rsquo;ve written a lot about immutable.js in the past (<a href="https://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/">here</a> and <a href="https://blog.mgechev.com/2015/04/11/immutability-in-angularjs-immutablejs-part-2/">here</a>), so now I&rsquo;ll make a very brief introduction.</p>

<p>Immutable.js provides a collection of immutable data structures. All of them have two essential properties:</p>

<ol>
<li>They are immutable (apparently), so when we aim to apply an operation which will mutate an instance of any of these data structures, we will get a new instance (which respectively has a new reference).</li>
<li>To produce a new data structure based on the applied operation with mutation immutable.js won&rsquo;t copy the entire data structure; instead it&rsquo;ll reuse as much as it can from the original one.</li>
</ol>

<p>Here&rsquo;s an example of the first point:</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">import</span> <span class="p">{</span> <span class="nx">List</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;immutable&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [a, b, c]
</span><span class="c1"></span>
<span class="kr">const</span> <span class="nx">appended</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// [a, b, c]
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">appended</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="err">// [a, b, c, d]</span></code></pre></div>
<p>As we can see from the snippet above, when we invoke the <code>push</code> method of the <code>List</code> instance we get a new list which has the mutation applied. On top of that, the list we applied the mutation to stays unchanged.</p>

<p>Based on the second property we can conclude that the immutable data structures from immutable.js will be much more efficient compared to what we did in the example above - copying the entire data structure on change.</p>

<h2 id="on-push-and-immutable-js">On Push and Immutable.js</h2>

<p>In order to see what are going to be the performance implications of using <code>OnPush</code> with immutable.js, I developed an e2e test with protractor which types a number of characters in the text input for the sales department. On top of that, I run <a href="https://www.npmjs.com/package/@angular/benchpress">benchpress</a> on top of it which by using APIs provided by Google Chrome can measure the time required for this operation to be completed.</p>

<p>The e2e test I run for both - the optimized version of the application (<code>OnPush</code> &amp; Immutable.js) and the non-optimized one. Here are the results:</p>

<p><img src="/images/faster-ng-apps-1/onpush-vs-non-optimized.png" style="border: 1px solid #ccc;"></p>

<p>It looks like we have a decent optimization. We&rsquo;re about 3x faster! Based on the benchmarks it looks like typing the string &ldquo;AngularConnect&rdquo; in the sales department&rsquo;s input took 13124.81ms for the non-optimized version and 5804.12ms for the optimized one.</p>

<p>Lets see the typing speed again:</p>

<p><img src="/images/faster-ng-apps-1/slow-on-push.gif" style="border: 1px solid #ccc;"></p>

<p>All right, so we&rsquo;re still quite slow. As we can see, the <code>calculate</code> method gets executed less frequently but still gets invoked quite a lot. If we take a more careful look, we can notice that this time we recalculate only the numeric values for all the employees in the sales department. So, <code>OnPush</code> optimization <em>almost worked</em>.</p>

<p>While typing, we&rsquo;re not getting new instances of the <code>salesList</code> since we&rsquo;re not applying any operations which are mutating it. Why we&rsquo;re getting the change detection for the sales department triggered?</p>

<p>The answer lies in the way <code>OnPush</code> works. Using <code>OnPush</code> change detection strategy the change detection for a given component will be triggered when we pass a new value to any of its inputs <strong>or when an event inside of the component happens</strong>. The second part is not completely obvious from the documentation, but it can be seen in <strong><a href="https://github.com/angular/angular/blob/56238fe94e5022f2a4c450ba9a23022bfff81eb9/packages/core/test/linker/integration_spec.ts#L641-L677">this e2e test</a></strong> in the Angular&rsquo;s core repository.</p>

<h2 id="enforcing-separation-of-concerns">Enforcing Separation of Concerns</h2>

<p>To fix this, we need to do some refactoring. This will help us not only to eliminate the unnecessary change detection invocations but also enforce better separation of concerns in our application.</p>

<p>For this purpose, we will decompose the <code>EmployeeListComponent</code> to:</p>

<ul>
<li><code>NameInputComponent</code> - responsible for holding the new name of the employee we want to add to the list.</li>
<li><code>ListComponent</code> - will list the individual employees and calculate their numeric values:</li>
</ul>

<p><img src="/images/faster-ng-apps-1/enforce-separation-of-concerns.png"></p>

<p>Now lets run the e2e tests again and see what we got:</p>

<p><img src="/images/faster-ng-apps-1/fast-typing.png" style="border: 1px solid #ccc;"></p>

<p>It may look like there&rsquo;s a glitch in the chart. No there isn&rsquo;t, we&rsquo;re just hundreds of times faster - 13124.81ms vs. 10.45ms for typing the string &ldquo;AngularConnect.&rdquo;</p>

<p>And here&rsquo;s the user experience when typing in the text input for the optimized version:</p>

<p><img src="/images/faster-ng-apps-1/fast-typing.gif" style="border: 1px solid #ccc;"></p>

<h1 id="conclusion">Conclusion</h1>

<p>In this part of the series &ldquo;Faster Angular Applications,&rdquo; we covered how we can optimize an Angular application regarding runtime performance by using immutable data structures and a custom change detection strategy.</p>

<p>We started by introducing a sample business application which lists two departments of employees and using a heavy computation calculates a numeric value for each of them.</p>

<p>There were some apparent slowdowns in the app caused by the two-way data-binding that we&rsquo;re using - the typing experience for entering a new employee was extremely slow. To reduce the number of computations going on we used <code>OnPush</code> change detection strategy and immutable data structures.</p>

<p>Although <code>OnPush</code> introduced a significant improvement we missed a very important detail - it causes Angular to detect for changes when an event inside of the given component gets triggered. We fixed this issue by decomposing the <code>EmployeeListComponent</code> and enforcing better separation of concerns.</p>

<p>In the next blog post from the series, we&rsquo;ll take a look at pure pipes. We&rsquo;ll also illustrate how pure pipes and <code>OnPush</code> change detection relate to functional programming and more precisely pure functions &amp; memoization.</p>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mgechev';

     
    (function () {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    <div class="by-author">with <i class="fa fa-heart" aria-hidden="true"></i> by Minko Gechev</div>
    <p class="small">
         © Copyright 2021  
    </p>
</footer>
        </section>

        <script src="https://blog.mgechev.com/js/main.js"></script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-18060688-3', 'auto');
	
	ga('send', 'pageview');
}
</script>



<script async src="//twemoji.maxcdn.com/2/twemoji.min.js?2.3.0"></script>
<script>
  window.addEventListener('load', function () {
    twemoji.parse(document.body, { size: 72 });
  });
</script>



    </body>
</html>
