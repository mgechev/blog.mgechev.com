<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tooling on Minko Gechev&#39;s blog</title>
    <link>https://blog.mgechev.com/categories/Tooling/</link>
    <description>Recent content in Tooling on Minko Gechev&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.mgechev.com/categories/Tooling/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dynamic imports solve all the problems, right?</title>
      <link>https://blog.mgechev.com/2019/05/11/dynamic-imports-javascript/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2019/05/11/dynamic-imports-javascript/</guid>
      <description>Since Angular version 8, we support dynamic imports in loadChildren in the route declaration. In this article, I want to give more information about why dynamic imports could be tricky to handle from tooling perspective and why you should be careful with them.
As engineers, we often have the perception that dynamic == good. With statically typed languages, such as TypeScript, this has shifted over the years. Because of compile-time checking, more folks started appreciating what tooling can give us if we provide statically analyzable information at build time.</description>
    </item>
    
    <item>
      <title>Fast, extensible, configurable, and beautiful linter for Go</title>
      <link>https://blog.mgechev.com/2018/05/28/revive-golang-golint-linter/</link>
      <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2018/05/28/revive-golang-golint-linter/</guid>
      <description>About a year ago I decided to polish my Go skills. Although the language is pretty small compared to most others that I use on a daily basis, it still has some useful syntax constructs that I didn&amp;rsquo;t use enough. What a better way to brush up your skills in a programming language other than building tools with it&amp;hellip;for analyzing programs written in it?
You can find revive on GitHub at github.</description>
    </item>
    
    <item>
      <title>Introducing Guess.js - a toolkit for enabling data-driven user-experiences on the Web</title>
      <link>https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/</link>
      <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/</guid>
      <description>About two months ago I published my initial research[1] on data-driven bundling. A few weeks after that, I had the opportunity to present my work on RenderConf in Oxford, UK in my talk &amp;ldquo;Teach Your Bundler Users&amp;rsquo; Habits&amp;rdquo;[2].
The original goal of the article was to show how data can help in improving the user-perceived page load performance by using predictive analytics[3]. The artifacts from the article were executable node modules which can be used for predictive pre-fetching &amp;amp; data-driven clustering of JavaScript chunks.</description>
    </item>
    
    <item>
      <title>Machine Learning-Driven Bundling. The Future of JavaScript Tooling.</title>
      <link>https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/</link>
      <pubDate>Sun, 18 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/</guid>
      <description>In this article, I&amp;rsquo;ll introduce the early implementation of a few tools which based on techniques from the machine learning allow us to perform data-driven chunk clustering and pre-fetching for single-page applications. The purpose is to provide a zero-configuration mechanism which based on data from Google Analytics for the users&amp;rsquo; behavior performs the most optimal build. We&amp;rsquo;re also going to introduce a webpack plugin which works with Angular CLI and Create React App.</description>
    </item>
    
    <item>
      <title>7 Angular Tools That You Should Consider</title>
      <link>https://blog.mgechev.com/2017/04/23/angular-tooling-codelyzer-angular-cli-ngrev/</link>
      <pubDate>Sun, 23 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2017/04/23/angular-tooling-codelyzer-angular-cli-ngrev/</guid>
      <description>In this article we&amp;rsquo;re going to quickly explore 7 Angular development tools which can make our everyday life easier. The purpose of the list is to not be opinionated architecture wise. This means that we&amp;rsquo;re not going to discuss tooling which has impact over our choice of application state management, data layer, etc. For instance, although packages like ngrx/store devtools, universal, and others are amazing once we&amp;rsquo;ve chosen a specific architectural approach, we&amp;rsquo;re going to keep them out of this article because they assume we&amp;rsquo;re using a specific way of state management or application rendering.</description>
    </item>
    
    <item>
      <title>Announcing ngrev - Reverse Engineering Tool for Angular</title>
      <link>https://blog.mgechev.com/2017/04/09/reverse-engineering-for-angular-ngrev/</link>
      <pubDate>Sun, 09 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2017/04/09/reverse-engineering-for-angular-ngrev/</guid>
      <description>Have you ever been hired to work on a huge legacy Angular project with thousands of NgModules, components, directives, pipes and services? Neither do I. Angular (2 and above) is still relatively new framework and there are not many enormous projects out there. On the other hand, Angular is powerful and in combination with TypeScript we can build big, enterprise applications.
Exploring an Application It&amp;rsquo;s hard to start digging into a large codebase without being aware of the overall structure of the project.</description>
    </item>
    
    <item>
      <title>Angular 2 Hot Loader</title>
      <link>https://blog.mgechev.com/2015/10/26/angular2-hot-loader-hot-loading-tooling/</link>
      <pubDate>Mon, 26 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mgechev.com/2015/10/26/angular2-hot-loader-hot-loading-tooling/</guid>
      <description>A couple of months ago I watched a few talks from ReactEurope. I was truly impressed by a few of them and especially by the one by Dan Abramov on redux and his hot loader. The tool he shown helps you do something similar to live-reload with one big difference. When you change the code of any of the components in your react application, the new version of the component is send to the application itself where all its instances are patched so the changes you did to be visible.</description>
    </item>
    
  </channel>
</rss>